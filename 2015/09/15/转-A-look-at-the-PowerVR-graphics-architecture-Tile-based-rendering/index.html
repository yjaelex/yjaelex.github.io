<!-- build time:Tue Jan 03 2017 17:42:58 GMT+0800 (China Standard Time) --><!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="UTF-8"><title>[转]A look at the PowerVR graphics architecture: Tile-based rendering-蓝天和白云的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="author" content="Alex"><meta name="keywords" content="计算机图形, yjaelex, 蓝天和白云"><meta name="google-site-verification" content="9lcaJdZKsghYWk19tQSzSIdlKxsT0jta8L0Qnc2WLSM"><meta name="baidu-site-verification" content="OBtOsRFDKB"><meta name="description" content="转一篇Imagination论坛上的牛人写的关于Tile-Based Rendering的文章。有空的话可以翻译下"><meta property="og:type" content="article"><meta property="og:title" content="[转]A look at the PowerVR graphics architecture: Tile-based rendering"><meta property="og:url" content="http://yjaelex.github.io/2015/09/15/转-A-look-at-the-PowerVR-graphics-architecture-Tile-based-rendering/index.html"><meta property="og:site_name" content="蓝天和白云的博客"><meta property="og:description" content="转一篇Imagination论坛上的牛人写的关于Tile-Based Rendering的文章。有空的话可以翻译下"><meta property="og:image" content="http://static.blog.csdn.net/xheditor/xheditor_emot/default/smile.gif"><meta property="og:image" content="http://blog.imgtec.com/wp-content/uploads/2013/05/IMR-Pipeline.jpg"><meta property="og:image" content="http://blog.imgtec.com/wp-content/uploads/2013/05/TBDR-Pipeline.jpg"><meta property="og:image" content="http://blog.imgtec.com/wp-content/uploads/2013/10/TBDR-architecture.png"><meta property="og:image" content="http://blog.imgtec.com/wp-content/uploads/2014/10/PowerVR-Series7-Series7XT-architecture.png"><meta property="og:image" content="http://blog.imgtec.com/wp-content/uploads/2015/03/PowerVR-TBDR-perfect-tiling.png"><meta property="og:updated_time" content="2016-12-29T08:39:26.111Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="[转]A look at the PowerVR graphics architecture: Tile-based rendering"><meta name="twitter:description" content="转一篇Imagination论坛上的牛人写的关于Tile-Based Rendering的文章。有空的话可以翻译下"><meta name="twitter:image" content="http://static.blog.csdn.net/xheditor/xheditor_emot/default/smile.gif"><link rel="alternative" href="/atom.xml" title="蓝天和白云的博客" type="application/atom+xml"><link rel="icon" href="/img/favicon.ico"><link rel="apple-touch-icon" href="/img/jacman.jpg"><link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg"><link rel="stylesheet" href="/css/style.css"></head></html><body><header><div><div id="imglogo"><a href="/"><img src="/img/logo.png" alt="蓝天和白云的博客" title="蓝天和白云的博客"></a></div><div id="textlogo"><h1 class="site-name"><a href="/" title="蓝天和白云的博客">蓝天和白云的博客</a></h1><h2 class="blog-motto">一个计算机图形爱好者</h2></div><div class="navbar"><a class="navbutton navmobile" href="#" title="菜单"></a></div><nav class="animated"><ul><ul><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/about">关于</a></li><li><form class="search" action="http://zhannei.baidu.com/cse/search" target="_blank"><label>Search</label><input name="s" type="hidden" value="6862289814022638000"><input type="text" name="q" size="30" placeholder="搜索"><br></form></li></ul></ul></nav></div></header><div id="container"><div id="main" class="post" itemscope itemprop="blogPost"><article itemprop="articleBody"><header class="article-info clearfix"><h1 itemprop="name"><a href="/2015/09/15/转-A-look-at-the-PowerVR-graphics-architecture-Tile-based-rendering/" title="[转]A look at the PowerVR graphics architecture: Tile-based rendering" itemprop="url">[转]A look at the PowerVR graphics architecture: Tile-based rendering</a></h1><p class="article-author">By <a href="/about" title="Alex" target="_blank" itemprop="author">Alex</a></p><p class="article-time"><time datetime="2015-09-15T08:21:23.000Z" itemprop="datePublished">发表于 2015-09-15</time></p></header><div class="article-content"><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong></div><p>转一篇Imagination论坛上的牛人写的关于Tile-Based Rendering的文章。有空的话可以翻译下<img src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/smile.gif" alt="微笑"></p><a id="more"></a><p>#<br>A look at the PowerVR graphics architecture: Tile-based rendering</p><p>I’m fond of telling the story about why I joined Imagination. It goes along the lines of: despite offers to go work on graphics in much sunnier climes, I took the job working on PowerVR Graphics here in distinctly un-sunny Britain because I was really interested<br>in how&nbsp;<span style="margin:0;padding:0;border:0;outline:0;vertical-align:baseline;background:0 0"><span style="margin:0;padding:0;border:0;outline:0;vertical-align:baseline;background:0 0"><a href="http://www.imgtec.com/powervr/powervr-architecture.asp" rel="external nofollow noopener noreferrer" target="_blank">Tile-Based<br>Deferred Rendering (TBDR)</a></span></span>&nbsp;could work in practice. My graphics career to-date had been mostly focused on the conceptually simpler&nbsp;<span style="margin:0;padding:0;border:0;outline:0;vertical-align:baseline;background:0 0"><span style="margin:0;padding:0;border:0;outline:0;vertical-align:baseline;background:0 0">Immediate<br>Mode Renderers (IMRs)</span></span>&nbsp;of the day – mostly GeForces and Radeons.</p><p>And no offence to the folks who designed said GeForces and Radeons – a few of whom I am friends with and many more I know quite well, but the front-end architecture of a modern discrete IMR GPU isn’t the most exciting thing in the world. Designed around having<br>plenty of dedicated bandwidth, those GPUs go about the job of painting pixels in a reasonably inefficient way, but one that’s conceptually simple and manifests itself in silicon in a similarly simple way, which makes it relatively easy for the GPU architect<br>to design, spec and have built by the hardware team.</p><p><a href="http://blog.imgtec.com/wp-content/uploads/2013/05/IMR-Pipeline.jpg" rel="external nofollow noopener noreferrer" target="_blank"><img src="http://blog.imgtec.com/wp-content/uploads/2013/05/IMR-Pipeline.jpg" alt="IMR Pipeline"></a>Immediate<br>Mode Rendering at work</p><p>With an IMR you send work to the GPU and it gets drawn straight away. There’s little connection to what else has already been drawn, or will be drawn in the future. You send triangles, you shade them. You rasterise them into pixels, you shade those. You send<br>the rendered pixels to the screen. Triangles in, pixels out, job done! But, crucially the job is done with no context of what’s already happened, or what might happen in the future.</p><p>PowerVR GPUs are about as different as they come in that respect, and it’s that which made me take the job here, to figure out how PowerVR’s architects, hardware teams and software folks had made TBDR actually work in real products. My instinct was that TBDRs<br>would be too complex to build so that they’d work well and actually provide a benefit. I had a chance to figure it out and five years later I’m still here, helping figure out how we’ll evolve it in the future, along with the rest of the GPU’s microarchitecture.</p><p>As far as the graphics programmer is concerned, PowerVR still looks like&nbsp;<span style="margin:0;padding:0;border:0;outline:0;vertical-align:baseline;background:0 0">triangles in, pixels out, job done</span>. But under the hood something<br>much more exciting is happening. And while the exciting part put me in this chair so I could write about it 5 years later, crucially it’s also that other good E word: efficient!</p><p>####<br>It always starts with the classic TBDR vs. IMR debate</p><p>To help understand why, let’s keep talking about IMRs. One of the biggest things stopping a desktop-class IMR scaling down to fit the power, performance and area budgets of modern embedded application processors is bandwidth. It’s such a scarce resource, even<br>in high-end processors – mostly because of power, area, wiring and packaging limitations, among other things – that you&nbsp;<span style="margin:0;padding:0;border:0;outline:0;vertical-align:baseline;background:0 0"><span style="margin:0;padding:0;border:0;outline:0;vertical-align:baseline;background:0 0">really</span></span>&nbsp;need<br>to use it as efficiently as possible.</p><p>IMRs don’t do that very well, especially when pixel shading. Remember that there are usually a great many more pixels being rendered than the vertices used to build triangles. On top of that, with an IMR pixels are often still shaded despite never being visible<br>on the screen, and that costs large amounts of precious bandwidth and power. Here’s why.</p><p>Textures for those pixels need to be sampled, and those pixels need to be written out to memory – and often read back in and written out again! – before being drawn on the screen. While all modern IMRs have means in hardware to try and avoid some of that redundant<br>work, say one building in the background being completely obscured by one drawn closer to you, there are things the application developer can do to effectively disable those mechanisms, such as always drawing the building in the background first.</p><p>In our architecture it doesn’t really matter how the application developer draws what’s on the screen. There are exceptions for non-opaque geometry, which the developer still needs to manage, but otherwise we’re submission order independent. That capability<br>is something we’ve had in our hardware since before we were ever an IP company and still made&nbsp;<a href="http://www.imgtec.com/news/detail.asp?ID=58" rel="external nofollow noopener noreferrer" target="_blank">our<br>own standalone PC and console GPUs</a>. You could draw the building in the background first, then the one in the foreground on top, and we’ll never perform pixel shading for the first one, unlike an IMR.</p><p>We effectively sort all of the opaque geometry in the GPU, regardless of how and when it was submitted by the application, to figure out the top-most triangles. Sure, if a developer perfectly sorts their geometry then an IMR can get much closer to our efficiency,<br>but that’s not the common case by any means.</p><p><a href="http://blog.imgtec.com/wp-content/uploads/2013/05/TBDR-Pipeline.jpg" rel="external nofollow noopener noreferrer" target="_blank"><img src="http://blog.imgtec.com/wp-content/uploads/2013/05/TBDR-Pipeline.jpg" alt="TBDR Pipeline"></a>PowerVR<br>TBDRs</p><p>Think again about all the work that’s saving, especially for modern content: for&nbsp;<span style="margin:0;padding:0;border:0;outline:0;vertical-align:baseline;background:0 0"><span style="margin:0;padding:0;border:0;outline:0;vertical-align:baseline;background:0 0">every<br>pixel</span></span>shaded there are going to be a non-trivial amount of texture lookups for various things, dozens and sometimes hundreds of ALU cycles spent to run computation on that texture data in order to apply the right effects, which often means writing<br>the pixel out to an intermediate surface to be read back in again in a further rendering pass, and then the pixel needs to be stored in memory at the end of shading, so it can be displayed on screen.</p><p>And that’s just one optimisation that we have. So even though we’ve avoided processing completely occluded geometry, there’s still bandwidth saving work we can do at the pixel processing stage. Because we split the screen up into tiles, where we figure out<br>all of the geometry that contributes to the tile so we only process what we need to, and we know exactly how big the tile is (currently 32×32 pixels, but it’s been smaller and even non-square in prior designs), we can build enough on-chip storage to process<br>a few of those tiles at a time, without having to use storage in external memory again until we’ve finished and want to write the final pixels out.</p><p><a href="http://blog.imgtec.com/wp-content/uploads/2013/10/TBDR-architecture.png" rel="external nofollow noopener noreferrer" target="_blank"><img src="http://blog.imgtec.com/wp-content/uploads/2013/10/TBDR-architecture.png" alt="TBDR architecture"></a>PowerVR<br>GPUs split the screen into tiles</p><p>There are secondary benefits to working on screen, region at a time; benefits that other GPUs take advantage of too: because it’s highly likely that a pixel on the screen will share some data with its immediate neighbours, it’s likely that when we move on to<br>processing the neighbouring pixels that we’ve fetched the data into cache and don’t have to wait for another set of external memory accesses, saving bandwidth again. It’s a classic exploitation of spatial locality that’s present in a lot of modern 3D rendering.</p><p>So that’s the top-level view of the biggest benefits of a TBDR versus an IMR in terms of processing and (especially) bandwidth efficiency. But how does it actually work in hardware? If you’re not too hardware inclined you can stop here! If you go no further,<br>you’ll still have understood the big top-level benefits of how we go about making best use of the available and very precious bandwidth, throughout rendering on in embedded, low-power systems.</p><p>####<br>How TBDR works in hardware</p><p>For those interested in how things happen in the hardware, let’s talk about the tiler in context of&nbsp;<a href="http://blog.imgtec.com/powervr/powervr-rogue-designing-an-optimal-architecture-for-graphics-and-gpu-compute" rel="external nofollow noopener noreferrer" target="_blank">a<br>modern Rogue GPU</a>.</p><p>A 3D graphics application starts by telling us where its geometry is in memory, so we ask the GPU to fetch it and perform vertex shading. We have blocks in our GPUs that are responsible for the non-programmable steps of each kind of task type, called&nbsp;<span style="margin:0;padding:0;border:0;outline:0;vertical-align:baseline;background:0 0"><span style="margin:0;padding:0;border:0;outline:0;vertical-align:baseline;background:0 0">the<br>data masters</span></span>. They do a bunch of different things on behalf of&nbsp;<span style="margin:0;padding:0;border:0;outline:0;vertical-align:baseline;background:0 0"><span style="margin:0;padding:0;border:0;outline:0;vertical-align:baseline;background:0 0">the<br>Universal Shading Cluster or USC</span></span>&nbsp;(our shading core) to do the fixed function bits of any workload, including fetch data from memory. So because we’re vertex shading, it’s&nbsp;<span style="margin:0;padding:0;border:0;outline:0;vertical-align:baseline;background:0 0"><span style="margin:0;padding:0;border:0;outline:0;vertical-align:baseline;background:0 0">the<br>vertex data master (VDM)</span></span>&nbsp;that gets involved at this point, to fetch the vertex data from memory based on information provided by the driver.</p><p><a href="http://blog.imgtec.com/wp-content/uploads/2014/10/PowerVR-Series7-Series7XT-architecture.png" rel="external nofollow noopener noreferrer" target="_blank"><img src="http://blog.imgtec.com/wp-content/uploads/2014/10/PowerVR-Series7-Series7XT-architecture.png" alt="PowerVR Series7 - Series7XT architecture"></a>PowerVR<br>Series7XT is the latest family of Rogue GPUs</p><p>The data could be stored in memory as lines, triangles or points. It could be indexed or non-indexed. There are associated shader programs and accompanying data for those programs. The VDM fetches whatever’s needed, using another couple of internally-programmable<br>blocks to help, and emits it all to the USC for vertex shading. The USC runs the shader program and the output vertices are stored on-chip.</p><p>They’re then consumed by hardware that performs primitive assembly, certain kinds of culling, and then clipping. If the geometry is back-facing or can be determined to be completely off the screen, it’s culled. All of the remaining on-screen front-facing geometry<br>is sent to be clipped. There’s a fast path here for geometry that doesn’t intersect a clip plane, to let it make onwards progress with no extra processing bar the intersection test. If the geometry intersects with a plane, the clipper generates new geometry<br>so that passed-on vertices are fully on-screen (even though they might be right at the edges). The clipper can do some other cool things, but they’re not too relevant for a big picture explanation like this.</p><p>Then we’re on to where a lot of the magic happens, compared to IMRs. We’re obviously aiming to run computation in multiple phases in the hardware, to maximise efficiency and occupancy: one front-end phase to figure out what’s going on with shaded geometry and<br>bin it into tiles, then one phase to consume that binned data, rasterise it and pass it on for pixel shading and final write-out. To keep things as efficient as possible that intermediate acceleration structure between the two main phases has to be as optimal<br>as we can make it.</p><p>Clearly it’s a bandwidth cost to create it and read it back, one which our competitors like to pick on when it comes to a competitive advantage they have over us. And it’s true; an IMR doesn’t have to deal with it. But given the bandwidth savings we have in<br>our processing model, creating that acceleration structure – which we call&nbsp;<span style="margin:0;padding:0;border:0;outline:0;vertical-align:baseline;background:0 0"><span style="margin:0;padding:0;border:0;outline:0;vertical-align:baseline;background:0 0">the<br>Parameter Buffer (PB)</span></span>&nbsp;– before feeding it to our trick rasteriser, we still end up with a huge bandwidth advantage in typical rendering situations, especially complex game-like scenes.</p><p>So how do we generate the PB? The clipper outputs a stream of primitives and render target IDs into memory, grouped by render target. Think of it as a container around collections of related geometry. The relationship is critical: we don’t want to read it later<br>and not consume a majority of the data that’s inside, since that’d be wasteful. The output at this stage is the main data structure stored in the PB. We then compress the memory, and in the general case it always compresses very well, so we save quite a lot<br>of PB creation bandwidth just from that step alone.</p><p>####<br>The concept of tiling</p><p>Now for the bit that most people sort of understand about our hardware architecture: tiling. The tiling engine has one main job: output some data that marks out a tiled region, some associated state, and a set of pointers to the geometry that contributes to<br>that region. We also store masks just in case a primitive doesn’t actually contribute to the region, but is stored in memory anyway. That lets us save some bandwidth and processing for that geometry, because it doesn’t contribute to the tile.</p><p>We call the resulting data structure a primitive list. If you’ve ever consumed any of&nbsp;<a href="http://community.imgtec.com/developers/powervr/documentation/" rel="external nofollow noopener noreferrer" target="_blank">our<br>developer documentation</a>, you’ll have seen mention of primitive lists as the intermediate data structure between the front-end phase and the pixel processing phase. Next, some more magic that’s specific to the PowerVR way of doing things.</p><p>Imagine you were tasked with building this bit of the architecture yourself, where you had to determine what regions need to be rasterised for a given set of geometries. There’s one obvious algorithm you could choose: the bounding box. Draw a box around the<br>triangle that covers its extents, and whatever tiles that box touches are the ones you rasterise for that triangle. That falls down pretty quickly though, efficiency wise.</p><p>Imagine a fairly long and thin triangle drawn across the screen in any orientation. You can quickly picture that the bounding box for that triangle is going to lie over tiles that the triangle doesn’t actually touch. So when you rasterise, you’re going to generate<br>work for your shading core, but where nothing is actually going to happen in terms of a contribution to the screen.</p><p>Instead, we have an algorithm baked into the hardware which we call&nbsp;<span style="margin:0;padding:0;border:0;outline:0;vertical-align:baseline;background:0 0"><span style="margin:0;padding:0;border:0;outline:0;vertical-align:baseline;background:0 0">perfect<br>tiling</span></span>. It works as you’d expect: we only generate tile lists where the geometry actually covers some area in the tile. It’s one of the most optimised and most efficient parts of the design. The perfect tiling engine generates that perfect list<br>of tiles for a given set of geometry.</p><p><a href="http://blog.imgtec.com/wp-content/uploads/2015/03/PowerVR-TBDR-perfect-tiling.png" rel="external nofollow noopener noreferrer" target="_blank"><img src="http://blog.imgtec.com/wp-content/uploads/2015/03/PowerVR-TBDR-perfect-tiling.png" alt="PowerVR TBDR - perfect tiling"></a>PowerVR<br>perfect tiling vs. bounding box or hierarchical tiling</p><p>That tile information plus the primitive lists are packed into the PB as efficiently as we can, and that’s conceptually pretty much it. In reality there’s a heck of a lot that still happens here in the hardware at the back-end phase of tiling, to fill the PB<br>and organise and marshal the actual memory accesses for the external memory writes, but in terms of functionality to wrap your head around, we’re pretty much done.</p><p>That front-end hardware architecture for us is really where a really big chuck of the efficiency gains can be found in a modern PowerVR GPU, compared to some of our competition. Surprisingly to those who find out, it’s part of the hardware architecture that’s<br>not actually that different, at least at the top-level, between Rogue and SGX. While we completely redesigned the shader core for Rogue, the front-end architecture actually bears a strong resemblance to the one you’ll find in&nbsp;<a href="http://blog.imgtec.com/powervr/understanding-powervr-sgx-mobiles-leading-gpu" rel="external nofollow noopener noreferrer" target="_blank">the<br>later generation SGX GPU IPs</a>. It works and it works very well.</p><p>And now that I’m done explaining the tiling part of our TBDR, it’s a good excuse to stop! I’ll come back to the deferred rendering part in a future blog post, so stay tuned.</p><p><br>本文地址 <a href="http://yjaelex.github.io/2015/09/15/转-A-look-at-the-PowerVR-graphics-architecture-Tile-based-rendering/">http://yjaelex.github.io/2015/09/15/转-A-look-at-the-PowerVR-graphics-architecture-Tile-based-rendering/</a> 作者为<a href="/about/"> Alex</a></p></div><div style="font-size:16px;BORDER-BOTTOM:#bbb 1px solid;BORDER-LEFT:#bbb 1px solid;BACKGROUND:#f6f6f6;MIN-HEIGHT:120px;BORDER-TOP:#bbb 1px solid;BORDER-RIGHT:#bbb 1px solid;MARGIN-LEFT:10px;MARGIN-RIGHT:10px;MARGIN-BOTTOM:10px" class="oec2003right"><div style="MARGIN-TOP:10px;FLOAT:left;MARGIN-LEFT:10px;MARGIN-RIGHT:10px"><img alt="author:Alex" src="http://yjaelex.github.io/imgs/myself.jpg" width="100" height="100"></div><div style="LINE-HEIGHT:200%;MARGIN:10px;COLOR:#000">Author: <a href="https://www.linkedin.com/in/yjaelex" rel="external nofollow noopener noreferrer" target="_blank">Alex</a> &nbsp&nbsp&nbsp&nbsp Blog: <a href="http://yjaelex.github.io/">http://yjaelex.github.io/</a>&nbsp&nbsp&nbsp&nbsp Email: <a href="mailto:yjaelex@163.com" rel="external nofollow noopener noreferrer" target="_blank">yjaelex@163.com</a><br>I have almost 10 years of professional 3D graphics development experiences(D3D/OpenGL) and have solid experience of graphics driver developement, for both DirectX and OpenGL/ES.</div></div><footer class="article-footer clearfix"><div class="article-catetags"></div><div class="article-share" id="share"><div data-url="http://yjaelex.github.io/2015/09/15/转-A-look-at-the-PowerVR-graphics-architecture-Tile-based-rendering/" data-title="[转]A look at the PowerVR graphics architecture: Tile-based rendering | 蓝天和白云的博客" data-tsina="undefined" class="share clearfix"></div></div></footer></article><nav class="article-nav clearfix"><div class="prev"><a href="/2015/09/27/原-AMD-Mantle-API-学习笔记-Mantle简介/" title="[原]AMD Mantle API 学习笔记 -- Mantle简介"><strong>上一篇：</strong><br><span>[原]AMD Mantle API 学习笔记 -- Mantle简介</span></a></div><div class="next"><a href="/2015/09/09/原-AMD-Mantle-API-学习笔记-Mantle初始化/" title="[原]AMD Mantle API 学习笔记 -- Mantle初始化"><strong>下一篇：</strong><br><span>[原]AMD Mantle API 学习笔记 -- Mantle初始化</span></a></div></nav><section id="comments" class="comment"><div class="ds-thread" data-thread-key="2015/09/15/转-A-look-at-the-PowerVR-graphics-architecture-Tile-based-rendering/" data-title="[转]A look at the PowerVR graphics architecture: Tile-based rendering" data-url="http://yjaelex.github.io/2015/09/15/转-A-look-at-the-PowerVR-graphics-architecture-Tile-based-rendering/"></div></section></div><div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div><div id="toc" class="toc-aside"><strong class="toc-title">文章目录</strong></div><div id="asidepart"><div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div><aside class="clearfix"><div class="github-card"><p class="asidetitle">Github 名片</p><div class="github-card" data-github="yjaelex" data-width="220" data-height="119" data-theme="medium"><script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js"></script></div></div><div class="categorieslist"><p class="asidetitle">分类</p><ul><li><a href="/categories/Graphics/" title="Graphics">Graphics<sup>1</sup></a></li></ul></div><div class="tagcloudlist"><p class="asidetitle">标签云</p><div class="tagcloudlist clearfix"><a href="/tags/Graphics/" style="font-size:20px">Graphics</a> <a href="/tags/Mantle/" style="font-size:10px">Mantle</a></div></div><div class="archiveslist"><p class="asidetitle"><a href="/archives">归档</a></p><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">4</span></li></ul></div><div class="tagslist"><p class="asidetitle">标签</p><ul class="clearfix"><li><a href="/tags/Graphics/" title="Graphics">Graphics<sup>2</sup></a></li><li><a href="/tags/Mantle/" title="Mantle">Mantle<sup>1</sup></a></li></ul></div><div class="hotarticles"><p class="asidetitle">热评文章</p><div class="ds-top-threads" data-range="monthly" data-num-items="5"></div></div><div class="linkslist"><p class="asidetitle">友情链接</p><ul><li><a href="http://blog.csdn.net/qwertyu1234" target="_blank" title="蓝天和白云的CSDN博客">蓝天和白云的CSDN博客</a></li><li><a href="https://github.com/yjaelex/" target="_blank" title="Alex&#39;s Github" rel="external nofollow noopener noreferrer">Alex&#39;s Github</a></li></ul></div><div class="rsspart"><a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a></div></aside></div></div><footer><div id="footer"><div class="line"><span></span><div class="author"></div></div><section class="info"><p>图形学爱好者的家园<br></p></section><div class="social-font"><a href="https://github.com/yjaelex" target="_blank" class="icon-github" title="github" rel="external nofollow noopener noreferrer"></a> <a href="https://www.linkedin.com/in/yjaelex" target="_blank" class="icon-linkedin" title="linkedin" rel="external nofollow noopener noreferrer"></a> <a href="mailto:yjaelex@163.com" target="_blank" class="icon-email" title="Email Me" rel="external nofollow noopener noreferrer"></a></div><p class="copyright">Copyright ©2014-2017 <a href="/about" target="_blank" title="Alex">Alex</a></p></div><script type="text/javascript">var cnzz_protocol="https:"==document.location.protocol?" https://":" http://";document.write(unescape("%3Cspan style='display:none;' id='cnzz_stat_icon_1260545070'%3E%3C/span%3E%3Cscript src='"+cnzz_protocol+"s95.cnzz.com/z_stat.php%3Fid%3D1260545070' type='text/javascript'%3E%3C/script%3E"))</script><script type="text/javascript">!function(t,e,n,s,c,i,a){t.SwiftypeObject=c,t[c]=t[c]||function(){(t[c].q=t[c].q||[]).push(arguments)},i=e.createElement(n),a=e.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","//s.swiftypecdn.com/install/v2/st.js","_st"),_st("install","qFtymqNnfXjgmwxAJxMP","2.0.0")</script></footer><script src="/js/jquery-2.0.3.min.js"></script><script src="/js/jquery.imagesloaded.min.js"></script><script src="/js/gallery.js"></script><script src="/js/jquery.qrcode-0.12.0.min.js"></script><script type="text/javascript">$(document).ready(function(){function e(){"number"==typeof window.innerWidth?n=window.innerWidth:document.documentElement&&document.documentElement.clientWidth&&(n=document.documentElement.clientWidth)}$(".navbar").click(function(){$("header nav").toggleClass("shownav")});var n=0,s=$("#main"),a=$("#asidepart"),o=$(".closeaside"),d=$(".openaside");o.click(function(){a.addClass("fadeOut").css("display","none"),d.css("display","block").addClass("fadeIn"),s.addClass("moveMain")}),d.click(function(){d.css("display","none").removeClass("beforeFadeIn"),a.css("display","block").removeClass("fadeOut").addClass("fadeIn"),s.removeClass("moveMain")}),$(window).scroll(function(){d.css("top",Math.max(80,260-$(this).scrollTop()))}),$(window).resize(function(){e(),n>=1024?$("header nav").removeClass("shownav"):(s.removeClass("moveMain"),a.css("display","block").removeClass("fadeOut"),d.css("display","none"),$("#toc.toc-aside").css("display","none"))})})</script><script type="text/javascript">$(document).ready(function(){var c=$(".article-content>iframe"),n=$(".article-content>embed"),o=($("#toc"),$("#toc.toc-aside")),e=$(".openaside"),i=$(".closeaside");c.length>0&&c.wrap('<div class="video-container" />'),n.length>0&&n.wrap('<div class="video-container" />'),i.click(function(){o.css("display","block").addClass("fadeIn")}),e.click(function(){o.css("display","none")}),$(window).scroll(function(){o.css("top",Math.max(140,320-$(this).scrollTop()))})})</script><script type="text/javascript">$(document).ready(function(){function e(){"number"==typeof window.innerWidth?n=window.innerWidth:document.documentElement&&document.documentElement.clientWidth&&(n=document.documentElement.clientWidth);var e=n>1024?200:100,t={render:"image",size:e,fill:"#2ca6cb",text:r,radius:.5,quiet:1},a=$(".article-share-qrcode").position();$(".hoverqrcode").empty().css("width",e).css("height",e).css("left",a.left-e/2+20).css("top",a.top-e-10).qrcode(t)}var t=$(".share"),r=t.attr("data-url"),a=encodeURIComponent(r),i=t.attr("data-title"),c=t.attr("data-tsina"),o=(t.attr("description"),['<div class="hoverqrcode clearfix"></div>','<a class="overlay" id="qrcode"></a>','<a href="https://www.facebook.com/sharer.php?u='+a+'" class="article-share-facebook" target="_blank" title="Facebook"></a>','<a href="https://twitter.com/intent/tweet?url='+a+'" class="article-share-twitter" target="_blank" title="Twitter"></a>','<a href="#qrcode" class="article-share-qrcode" title="微信"></a>','<a href="http://widget.renren.com/dialog/share?resourceUrl='+a+"&srcUrl="+a+"&title="+i+'" class="article-share-renren" target="_blank" title="人人"></a>','<a href="http://service.weibo.com/share/share.php?title='+i+"&url="+a+"&ralateUid="+c+'&searchPic=true&style=number" class="article-share-weibo" target="_blank" title="微博"></a>','<span title="Share to"></span>'].join(""));t.append(o),$(".hoverqrcode").hide();var n=0;$(window).resize(function(){$(".hoverqrcode").hide()}),$(".article-share-qrcode").click(function(){e(),$(".hoverqrcode").toggle()}),$(".article-share-qrcode").hover(function(){},function(){$(".hoverqrcode").hide()})})</script><script type="text/javascript">var duoshuoQuery={short_name:"yjaelexblog"};!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//static.duoshuo.com/embed.js",e.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script type="text/javascript">$(document).ready(function(){$(".article-content").each(function(a){$(this).find("img").each(function(){if(!$(this).parent().hasClass("fancybox")){var a=this.alt;a&&$(this).after('<span class="caption">'+a+"</span>"),$(this).wrap('<a href="'+this.src+'" title="'+a+'" class="fancybox"></a>')}}),$(this).find(".fancybox").each(function(){$(this).attr("rel","article"+a)})}),$.fancybox&&$(".fancybox").fancybox()})</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?202299ed0711ed4f90ea1e0b0fd936f1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div id="totop"><a title="返回顶部"><img alt="返回顶部" src="/img/scrollup.png"></a></div><script src="/js/totop.js"></script></body><!-- rebuild by neat -->