<!-- build time:Fri Dec 30 2016 13:16:05 GMT+0800 (China Standard Time) --><!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="UTF-8"><title>[转][转]The Mali GPU: An Abstract Machine, Part 3 - The Shader Core-蓝天和白云的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="author" content="Alex"><meta name="keywords" content="计算机图形, yjaelex, 蓝天和白云"><meta name="google-site-verification" content="9lcaJdZKsghYWk19tQSzSIdlKxsT0jta8L0Qnc2WLSM"><meta name="baidu-site-verification" content="OBtOsRFDKB"><meta name="description" content="第三篇，介绍Shader Core。1. 英文原文In the first two blogs of this series I introduced the frame-level pipelining [TheMali GPU: An Abstract Machine, Part 1 - Frame Pipelining] and tile based rendering architectu"><meta property="og:type" content="article"><meta property="og:title" content="[转][转]The Mali GPU: An Abstract Machine, Part 3 - The Shader Core"><meta property="og:url" content="http://yjaelex.github.io/2015/12/03/转-转-The-Mali-GPU-An-Abstract-Machine-Part-3-The-Shader-Core/index.html"><meta property="og:site_name" content="蓝天和白云的博客"><meta property="og:description" content="第三篇，介绍Shader Core。1. 英文原文In the first two blogs of this series I introduced the frame-level pipelining [TheMali GPU: An Abstract Machine, Part 1 - Frame Pipelining] and tile based rendering architectu"><meta property="og:image" content="https://community.arm.com/servlet/JiveServlet/downloadImage/38-2906-7387/mali-top-level.png"><meta property="og:image" content="https://community.arm.com/servlet/JiveServlet/downloadImage/38-2906-7388/mali-top-core.png"><meta property="og:updated_time" content="2016-12-29T08:41:14.215Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="[转][转]The Mali GPU: An Abstract Machine, Part 3 - The Shader Core"><meta name="twitter:description" content="第三篇，介绍Shader Core。1. 英文原文In the first two blogs of this series I introduced the frame-level pipelining [TheMali GPU: An Abstract Machine, Part 1 - Frame Pipelining] and tile based rendering architectu"><meta name="twitter:image" content="https://community.arm.com/servlet/JiveServlet/downloadImage/38-2906-7387/mali-top-level.png"><link rel="alternative" href="/atom.xml" title="蓝天和白云的博客" type="application/atom+xml"><link rel="icon" href="/img/favicon.ico"><link rel="apple-touch-icon" href="/img/jacman.jpg"><link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg"><link rel="stylesheet" href="/css/style.css"></head></html><body><header><div><div id="imglogo"><a href="/"><img src="/img/logo.png" alt="蓝天和白云的博客" title="蓝天和白云的博客"></a></div><div id="textlogo"><h1 class="site-name"><a href="/" title="蓝天和白云的博客">蓝天和白云的博客</a></h1><h2 class="blog-motto">一个计算机图形爱好者</h2></div><div class="navbar"><a class="navbutton navmobile" href="#" title="菜单"></a></div><nav class="animated"><ul><ul><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/about">关于</a></li><li><form class="search" action="http://zhannei.baidu.com/cse/search" target="_blank"><label>Search</label><input name="s" type="hidden" value="6862289814022638000"><input type="text" name="q" size="30" placeholder="搜索"><br></form></li></ul></ul></nav></div></header><div id="container"><div id="main" class="post" itemscope itemprop="blogPost"><article itemprop="articleBody"><header class="article-info clearfix"><h1 itemprop="name"><a href="/2015/12/03/转-转-The-Mali-GPU-An-Abstract-Machine-Part-3-The-Shader-Core/" title="[转][转]The Mali GPU: An Abstract Machine, Part 3 - The Shader Core" itemprop="url">[转][转]The Mali GPU: An Abstract Machine, Part 3 - The Shader Core</a></h1><p class="article-author">By <a href="/about" title="Alex" target="_blank" itemprop="author">Alex</a></p><p class="article-time"><time datetime="2015-12-03T02:08:43.000Z" itemprop="datePublished">发表于 2015-12-03</time></p></header><div class="article-content"><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-英文原文"><span class="toc-number">1.</span> <span class="toc-text">1. 英文原文</span></a></li></ol></div><p>第三篇，介绍Shader Core。</p><h2 id="1-英文原文"><a href="#1-英文原文" class="headerlink" title="1. 英文原文"></a>1. 英文原文</h2><p>In the first two blogs of this series I introduced the frame-level pipelining [<a href="https://community.arm.com/groups/arm-mali-graphics/blog/2014/02/03/the-mali-gpu-an-abstract-machine-part-1" rel="external nofollow noopener noreferrer" target="_blank">The<br>Mali GPU: An Abstract Machine, Part 1 - Frame Pipelining</a>] and tile based rendering architecture [<a href="https://community.arm.com/groups/arm-mali-graphics/blog/2014/02/20/the-mali-gpu-an-abstract-machine-part-2" rel="external nofollow noopener noreferrer" target="_blank">The<br>Mali GPU: An Abstract Machine, Part 2 - Tile-based Rendering</a>] used by the Mali GPUs, aiming to develop a mental model which developers can use to explain the behavior of the graphics stack when optimizing the performance of their applications.</p><p>&nbsp;</p><p>In this blog I will finish the construction of this abstract machine, forming the final component: the Mali GPU itself.&nbsp; This blog assumes you have read the first two parts in the series, so I would recommend starting with those if you have not read them already.</p><p>&nbsp;</p><a id="more"></a><p>##<br>GPU Architecture</p><p>&nbsp;</p><p>The &quot;Midgard&quot; family of Mali GPUs&nbsp; (the Mali-T600 and Mali-T700 series) use a unified shader core architecture, meaning that only a single type of shader core exists in the design. This single core can execute all types of programmable shader code, including<br>vertex shaders, fragment shaders, and compute kernels.</p><p>&nbsp;</p><p>The exact number of shader cores present in a particular silicon chip varies; our silicon partners can choose how many shader cores they implement based on their performance needs and silicon area constraints. The Mali-T760 GPU can scale from a single core<br>for low-end devices all the way up to 16 cores for the highest performance designs, but between 4 and 8 cores are the most common implementations.</p><p>&nbsp;</p><p><a href="https://community.arm.com/servlet/JiveServlet/showImage/38-2906-7387/mali-top-level.png" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://community.arm.com/servlet/JiveServlet/downloadImage/38-2906-7387/mali-top-level.png" alt="mali-top-level.png"></a></p><p>The graphics work for the GPU is queued in a pair of queues, one for vertex/tiling workloads and one for fragment workloads, with all work for one render target being submitted as a single submission into each queue. Workloads from both queues can be processed<br>by the GPU at the same time, so vertex processing and fragment processing for different render targets can be running in parallel (see the first blog for more details on this pipelining methodology). The workload for a single render target is broken into smaller<br>pieces and distributed across all of the shader cores in the GPU, or in the case of tiling workloads (see the second blog in this series for an overview of tiling) a fixed function tiling unit.</p><p>&nbsp;</p><p>The shader cores in the system share a level 2 cache to improve performance, and to reduce memory bandwidth caused by repeated data fetches. Like the number of cores, the size of the L2 is configurable by our silicon partners, but is typically in the range<br>of 32-64KB per shader core in the GPU depending on how much silicon area is available. The number and bus width of the memory ports this cache has to external memory is configurable, again allowing our partners to tune the implementation to meet their performance,<br>power, and area needs. In general we aim to be able to write one 32-bit pixel per core per clock, so it would be reasonable to expect an 8-core design to have a total of 256-bits of memory bandwidth (for both read and write) per clock cycle.</p><p>&nbsp;</p><p>##<br>Mali GPU Shader Core</p><p>&nbsp;</p><p>The Mali shader core is structured as a number of fixed-function hardware blocks wrapped around a programmable &quot;tripipe&quot; execution core. The fixed function units perform the setup for a shader operation - such as rasterizing triangles or performing depth testing</p><ul><li>or handling the post-shader activities - such as blending, or writing back a whole tile’s worth of data at the end of rendering. The tripipe itself is the programmable part responsible for the execution of shader programs.</li></ul><p>&nbsp;</p><p><a href="https://community.arm.com/servlet/JiveServlet/showImage/38-2906-7388/mali-top-core.png" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://community.arm.com/servlet/JiveServlet/downloadImage/38-2906-7388/mali-top-core.png" alt="mali-top-core.png"></a></p><p>&nbsp;</p><p>###<br>The Tripipe</p><p>&nbsp;</p><p>There are three classes of execution pipeline in the tripipe design: one handling arithmetic operations, one handling memory load/store and varying access, and one handling texture access. There is one load/store and one texture pipe per shader core, but the<br>number of arithmetic pipelines can vary depending on which GPU you are using; most silicon shipping today will have two arithmetic pipelines, but GPU variants with up to four pipelines are also available.</p><p>&nbsp;</p><p>###<br>Massively Multi-threaded Machine</p><p>&nbsp;</p><p>Unlike a traditional CPU architecture, where you will typically only have a single thread of execution at a time on a single core, the tripipe is a massively multi-threaded processing engine. There may well be hundreds of hardware threads running at the same<br>time in the tripipe, with one thread created for each vertex or fragment which is shaded. This large number of threads exists to hide memory latency; it doesn’t matter if some threads are stalled waiting for memory, as long as at least one thread is available<br>to execute then we maintain efficient execution.</p><p>&nbsp;</p><p>###<br>Arithmetic Pipeline: Vector Core</p><p>&nbsp;</p><p>The arithmetic pipeline (A-pipe) is a&nbsp;<a href="https://community.arm.com/external-link.jspa?url=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FSIMD" rel="external nofollow noopener noreferrer" target="_blank">SIMD</a>&nbsp;(single<br>instruction multiple data) vector processing engine, with arithmetic units which operate on 128-bit quad-word registers. The registers can be flexibly accessed as either 2 x FP64, 4 x FP32, 8 x FP16, 2 x int64, 4 x int32, 8 x int16, or 16 x int8. It is therefore<br>possible for a single arithmetic vector task to operate on 8 &quot;mediump&quot; values in a single operation, and for OpenCL kernels operating on 8-bit luminance data to process 16 pixels per SIMD unit per clock cycle.</p><p>&nbsp;</p><p>While I can’t disclose the internal architecture of the arithmetic pipeline, our public performance data for each GPU can be used to give some idea of the number of maths units available. For example, the Mali-T760 with 16 cores is rated at 326 FP32 GFLOPS<br>at 600MHz. This gives a total of 34 FP32 FLOPS per clock cycle for this shader core; it has two pipelines, so that’s 17 FP32 FLOPS per pipeline per clock cycle. The available performance in terms of operations will increase for FP16/int16/int8 and decrease<br>for FP64/int64 data types.</p><p>&nbsp;</p><p>###<br>Texture Pipeline</p><p>&nbsp;</p><p>The texture pipeline (T-pipe) is responsible for all memory access to do with textures. The texture pipeline can return one bilinear filtered texel per clock; trilinear filtering requires us to load samples from two different mipmaps in memory, so requires<br>a second clock cycle to complete.</p><p>&nbsp;</p><p>###<br>Load/Store Pipeline</p><p>&nbsp;</p><p>The load/store pipeline (LS-pipe) is responsible for all memory accesses which are not related to texturing.&nbsp; For graphics workloads this means reading attributes and writing varyings during vertex shading, and reading varyings during fragment shading. In general<br>every instruction is a single memory access operation, although like the arithmetic pipeline they are vector operations and so could load an entire &quot;highp&quot; vec4 varying in a single instruction.</p><p>&nbsp;</p><p>###<br>Early ZS Testing and Late ZS Testing</p><p>&nbsp;</p><p>In the OpenGL ES specification &quot;fragment operations&quot; - which include depth and stencil testing - happen at the end of the pipeline, after fragment shading has completed. This makes the specification very simple, but implies that you have to spend lots of time<br>shading something, only to throw it away at the end of the frame if it turns out to be killed by ZS testing. Coloring fragments just to discard them would cost a huge amount of performance and wasted energy, so where possible we will do ZS testing early (i.e.<br>before fragment shading), only falling back to late ZS testing (i.e. after fragment shading) where it is unavoidable (e.g. a dependency on fragment which may call &quot;discard&quot; and as such has indeterminate depth state until it exits the tripipe).</p><p>&nbsp;</p><p>In addition to the traditional early-z schemes, we also have some overdraw removal capability which can stop fragments which have already been rasterized from turning into real rendering work if they do not contribute to the output scene in a useful way. My<br>colleague&nbsp;<a href="https://community.arm.com/people/seanellis" rel="external nofollow noopener noreferrer" target="_blank">seanellis</a>&nbsp;has<br>a great blog looking at this technology -<span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:inherit;vertical-align:baseline;line-height:1.5em">&nbsp;</span><a href="https://community.arm.com/groups/arm-mali-graphics/blog/2013/08/08/killing-pixels--a-new-optimization-for-shading-on-arm-mali-gpus" rel="external nofollow noopener noreferrer" target="_blank">Killing<br>Pixels - A New Optimization for Shading on ARM Mali GPUs&nbsp;</a><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:inherit;vertical-align:baseline;line-height:1.5em">- so I won’t dive into<br>any more detail here.</span></p><p>&nbsp;</p><p>##<br>Memory System</p><p>&nbsp;</p><p>This section is an after-the-fact addition to this blog, so if you have read this blog before and don’t remember this section, don’t worry you’re not going crazy. We have been getting a lot of questions from developers writing OpenCL kernels and OpenGL ES compute<br>shaders asking for more information about the GPU cache structure, as it can be really beneficial to lay out data structures and buffers to optimize cache locality. The salient facts are:</p><p>&nbsp;</p><ul><li>Two 16KB L1 data caches per shader core; one for texture access and one for generic memory access.</li><li>A single logical L2 which is shared by all of the shader cores. The size of this is variable and can be configured by the silicon integrator, but is typically between 32 and 64 KB per instantiated shader core.</li><li>Both cache levels<span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:inherit;vertical-align:baseline;line-height:1.5em">&nbsp;use 64 byte cache lines.</span></li></ul><p>&nbsp;</p><p>If you are new to optimization of massively multi-threaded algorithms on massively multi-threaded architectures I would heartily recommend the SGEMM matrix multiplication video on our Mali Developer portal here:</p><p>&nbsp;</p><ul><li><a href="https://community.arm.com/external-link.jspa?url=http%3A%2F%2Fmalideveloper.arm.com%2Fdevelop-for-mali%2Fopencl-renderscript-tutorials%2F%23example" rel="external nofollow noopener noreferrer" target="_blank">http://malideveloper.arm.com/develop-for-mali/opencl-renderscript-tutorials/#example</a></li></ul><p>&nbsp;</p><p>… as the overall system behavior can be very different to what you are used to if you are coming from a traditional CPU background.</p><p>&nbsp;</p><p>##<br>GPU Limits</p><p>&nbsp;</p><p>Based on this simple model it is possible to outline some of the fundamental properties underpinning the GPU performance.</p><p>&nbsp;</p><ul><li>The GPU can issue one vertex per shader core per clock</li><li>The GPU can issue one fragment per shader core per clock</li><li>The GPU can retire one pixel per shader core per clock</li><li><p>We can issue one instruction per pipe per clock, so for a typical shader core we can issue four instructions in parallel if we have them available to run</p><ul><li>We can achieve 17 FP32 operations per A-pipe</li><li>One vector load, one vector store, or one vector varying per LS-pipe</li><li>One bilinear filtered texel per T-pipe</li></ul></li><li><p>The GPU will typically have 32-bits of DDR access (read and write) per core per clock [configurable]</p></li></ul><p>&nbsp;</p><p><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:inherit;vertical-align:baseline;line-height:1.5em">If we scale this to a Mali-T760 MP8 running at 600MHz we can calculate the theoretical<br>peak performance as:</span></p><p>&nbsp;</p><ul><li><p>Fillrate:</p><ul><li>8 pixels per clock = 4.8 GPix/s</li><li><span style="margin:0;padding:0;border:0;font-weight:inherit;font-family:inherit;vertical-align:baseline">That’s 2314 complete 1080p frames per second!</span></li></ul></li><li><p>Texture rate:</p><ul><li>8 bilinear texels per clock = 4.8 GTex/s</li><li><span style="margin:0;padding:0;border:0;font-weight:inherit;font-family:inherit;vertical-align:baseline">That’s 38 bilinear filtered texture lookups per pixel for 1080p @ 60 FPS!</span></li></ul></li><li><p>Arithmetic rate:</p><ul><li>17 FP32 FLOPS per pipe per core = 163 FP32 GFLOPS</li><li><span style="margin:0;padding:0;border:0;font-weight:inherit;font-family:inherit;vertical-align:baseline">That’s 1311 FLOPS per pixel for 1080p @ 60 FPS!</span></li></ul></li><li><p>Bandwidth:</p><ul><li>256-bits of memory access per clock = 19.2GB/s read and write bandwidth<sup>1</sup><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:inherit;vertical-align:baseline;line-height:1.5em">.</span></li><li><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:inherit;vertical-align:baseline;line-height:1.5em"><span style="margin:0;padding:0;border:0;font-weight:inherit;font-size:13.33px;font-family:inherit;vertical-align:baseline">That’s<br>154 bytes per pixel for 1080p @ 60 FPS!</span></span></li></ul></li></ul><p>&nbsp;</p><p>##<br>OpenCL and Compute</p><p>&nbsp;</p><p>The observant reader will have noted that I’ve talked a lot about vertices and fragments - the staple of graphics work - but have mentioned very little about how OpenCL and RenderScript compute threads come into being inside the core. Both of these types of<br>work behave almost identically to vertex threads - you can view running a vertex shader over an array of vertices as a 1-dimensional compute problem. So the vertex thread creator also spawns compute threads, although more accurately I would say the compute<br>thread creator also spawns vertices&nbsp;<span class="emoticon-inline emoticon_wink" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;display:inline-block;height:16px;width:16px"></span>.</p><p>&nbsp;</p><p>##<br>Next Time …</p><p>&nbsp;</p><p>This blog concludes the first chapter of this series, developing the abstract machine which defines the basic behaviors which an application developer should expect to see for a Mali GPU in the Midgard family. Over the rest of this series I’ll start to put<br>this new knowledge to work, investigating some common application development pitfalls, and useful optimization techniques, which can be identified and debugged using the Mali integration into the ARM DS-5 Streamline profiling tools.</p><p>&nbsp;</p><p><span style="margin:0;padding:0;border:0;font-style:inherit;font-family:inherit;vertical-align:baseline">EDIT: Next blog now available:</span></p><ul><li><a href="https://community.arm.com/groups/arm-mali-graphics/blog/2014/04/02/mali-graphics-performance-1-checking-the-pipeline" rel="external nofollow noopener noreferrer" target="_blank">Mali<br>Performance 1: Checking the Pipeline</a></li></ul><p>&nbsp;</p><p>Comments and questions welcomed as always,</p><p>TTFN,</p><p>Pete</p><p>&nbsp;</p><p>###<br>Footnotes</p><p>&nbsp;</p><ol><li>… 19.2GB/s subject to the ability of the rest of the memory system outside of the GPU to give us data this quickly. Like most features of an ARM-based chip, the down-stream memory system is highly configurable in order to allow different vendors to tune power,<br>performance, and silicon area according to their needs. For most SoC parts the rest of the system will throttle the available bandwidth before the GPU runs out of an ability to request data. It is unlikely you would want to sustain this kind of bandwidth for<br>prolonged periods, but short burst performance is important.</li></ol><p><br>本文地址 <a href="http://yjaelex.github.io/2015/12/03/转-转-The-Mali-GPU-An-Abstract-Machine-Part-3-The-Shader-Core/">http://yjaelex.github.io/2015/12/03/转-转-The-Mali-GPU-An-Abstract-Machine-Part-3-The-Shader-Core/</a> 作者为<a href="/about/"> Alex</a></p></div><div style="font-size:16px;BORDER-BOTTOM:#bbb 1px solid;BORDER-LEFT:#bbb 1px solid;BACKGROUND:#f6f6f6;MIN-HEIGHT:120px;BORDER-TOP:#bbb 1px solid;BORDER-RIGHT:#bbb 1px solid;MARGIN-LEFT:10px;MARGIN-RIGHT:10px;MARGIN-BOTTOM:10px" class="oec2003right"><div style="MARGIN-TOP:10px;FLOAT:left;MARGIN-LEFT:10px;MARGIN-RIGHT:10px"><img alt="author:Alex" src="http://yjaelex.github.io/imgs/myself.jpg" width="100" height="100"></div><div style="LINE-HEIGHT:200%;MARGIN:10px;COLOR:#000">Author: <a href="https://www.linkedin.com/in/yjaelex" rel="external nofollow noopener noreferrer" target="_blank">Alex</a> &nbsp&nbsp&nbsp&nbsp Blog: <a href="http://yjaelex.github.io/">http://yjaelex.github.io/</a>&nbsp&nbsp&nbsp&nbsp Email: <a href="mailto:yjaelex@163.com" rel="external nofollow noopener noreferrer" target="_blank">yjaelex@163.com</a><br>I have almost 9 years of professional 3D graphics development experiences(D3D/OpenGL) and have solid experience of graphics driver developement, for both DirectX and OpenGL/ES.</div></div><footer class="article-footer clearfix"><div class="article-catetags"></div><div class="article-share" id="share"><div data-url="http://yjaelex.github.io/2015/12/03/转-转-The-Mali-GPU-An-Abstract-Machine-Part-3-The-Shader-Core/" data-title="[转][转]The Mali GPU: An Abstract Machine, Part 3 - The Shader Core | 蓝天和白云的博客" data-tsina="undefined" class="share clearfix"></div></div></footer></article><nav class="article-nav clearfix"><div class="prev"><a href="/2015/12/03/原-SPIR-V-研究：编译器基本原理（一）/" title="[原]SPIR-V 研究：编译器基本原理（一）"><strong>上一篇：</strong><br><span>[原]SPIR-V 研究：编译器基本原理（一）</span></a></div><div class="next"><a href="/2015/12/03/转-转-The-Mali-GPU-An-Abstract-Machine-Part-2-Tile-based-Rendering/" title="[转][转] The Mali GPU: An Abstract Machine, Part 2 - Tile-based Rendering"><strong>下一篇：</strong><br><span>[转][转] The Mali GPU: An Abstract Machine, Part 2 - Tile-based Rendering</span></a></div></nav><section id="comments" class="comment"><div class="ds-thread" data-thread-key="2015/12/03/转-转-The-Mali-GPU-An-Abstract-Machine-Part-3-The-Shader-Core/" data-title="[转][转]The Mali GPU: An Abstract Machine, Part 3 - The Shader Core" data-url="http://yjaelex.github.io/2015/12/03/转-转-The-Mali-GPU-An-Abstract-Machine-Part-3-The-Shader-Core/"></div></section></div><div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div><div id="toc" class="toc-aside"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-英文原文"><span class="toc-number">1.</span> <span class="toc-text">1. 英文原文</span></a></li></ol></div><div id="asidepart"><div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div><aside class="clearfix"><div class="github-card"><p class="asidetitle">Github 名片</p><div class="github-card" data-github="yjaelex" data-width="220" data-height="119" data-theme="medium"><script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js"></script></div></div><div class="categorieslist"><p class="asidetitle">分类</p><ul><li><a href="/categories/Graphics/" title="Graphics">Graphics<sup>1</sup></a></li></ul></div><div class="tagcloudlist"><p class="asidetitle">标签云</p><div class="tagcloudlist clearfix"><a href="/tags/Graphics/" style="font-size:20px">Graphics</a> <a href="/tags/Mantle/" style="font-size:10px">Mantle</a></div></div><div class="archiveslist"><p class="asidetitle"><a href="/archives">归档</a></p><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">4</span></li></ul></div><div class="tagslist"><p class="asidetitle">标签</p><ul class="clearfix"><li><a href="/tags/Graphics/" title="Graphics">Graphics<sup>2</sup></a></li><li><a href="/tags/Mantle/" title="Mantle">Mantle<sup>1</sup></a></li></ul></div><div class="hotarticles"><p class="asidetitle">热评文章</p><div class="ds-top-threads" data-range="monthly" data-num-items="5"></div></div><div class="linkslist"><p class="asidetitle">友情链接</p><ul><li><a href="http://blog.csdn.net/qwertyu1234" target="_blank" title="蓝天和白云的CSDN博客">蓝天和白云的CSDN博客</a></li><li><a href="https://github.com/yjaelex/" target="_blank" title="Alex&#39;s Github" rel="external nofollow noopener noreferrer">Alex&#39;s Github</a></li></ul></div><div class="rsspart"><a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a></div></aside></div></div><footer><div id="footer"><div class="line"><span></span><div class="author"></div></div><section class="info"><p>图形学爱好者的家园<br></p></section><div class="social-font"><a href="https://github.com/yjaelex" target="_blank" class="icon-github" title="github" rel="external nofollow noopener noreferrer"></a> <a href="https://www.linkedin.com/in/yjaelex" target="_blank" class="icon-linkedin" title="linkedin" rel="external nofollow noopener noreferrer"></a> <a href="mailto:yjaelex@163.com" target="_blank" class="icon-email" title="Email Me" rel="external nofollow noopener noreferrer"></a></div><p class="copyright">Copyright ©2014-2016 <a href="/about" target="_blank" title="Alex">Alex</a></p></div><script type="text/javascript">var cnzz_protocol="https:"==document.location.protocol?" https://":" http://";document.write(unescape("%3Cspan style='display:none;' id='cnzz_stat_icon_1260545070'%3E%3C/span%3E%3Cscript src='"+cnzz_protocol+"s95.cnzz.com/z_stat.php%3Fid%3D1260545070' type='text/javascript'%3E%3C/script%3E"))</script><script type="text/javascript">!function(t,e,n,s,c,i,a){t.SwiftypeObject=c,t[c]=t[c]||function(){(t[c].q=t[c].q||[]).push(arguments)},i=e.createElement(n),a=e.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","//s.swiftypecdn.com/install/v2/st.js","_st"),_st("install","qFtymqNnfXjgmwxAJxMP","2.0.0")</script></footer><script src="/js/jquery-2.0.3.min.js"></script><script src="/js/jquery.imagesloaded.min.js"></script><script src="/js/gallery.js"></script><script src="/js/jquery.qrcode-0.12.0.min.js"></script><script type="text/javascript">$(document).ready(function(){function e(){"number"==typeof window.innerWidth?n=window.innerWidth:document.documentElement&&document.documentElement.clientWidth&&(n=document.documentElement.clientWidth)}$(".navbar").click(function(){$("header nav").toggleClass("shownav")});var n=0,s=$("#main"),a=$("#asidepart"),o=$(".closeaside"),d=$(".openaside");o.click(function(){a.addClass("fadeOut").css("display","none"),d.css("display","block").addClass("fadeIn"),s.addClass("moveMain")}),d.click(function(){d.css("display","none").removeClass("beforeFadeIn"),a.css("display","block").removeClass("fadeOut").addClass("fadeIn"),s.removeClass("moveMain")}),$(window).scroll(function(){d.css("top",Math.max(80,260-$(this).scrollTop()))}),$(window).resize(function(){e(),n>=1024?$("header nav").removeClass("shownav"):(s.removeClass("moveMain"),a.css("display","block").removeClass("fadeOut"),d.css("display","none"),$("#toc.toc-aside").css("display","none"))})})</script><script type="text/javascript">$(document).ready(function(){var c=$(".article-content>iframe"),n=$(".article-content>embed"),o=($("#toc"),$("#toc.toc-aside")),e=$(".openaside"),i=$(".closeaside");c.length>0&&c.wrap('<div class="video-container" />'),n.length>0&&n.wrap('<div class="video-container" />'),i.click(function(){o.css("display","block").addClass("fadeIn")}),e.click(function(){o.css("display","none")}),$(window).scroll(function(){o.css("top",Math.max(140,320-$(this).scrollTop()))})})</script><script type="text/javascript">$(document).ready(function(){function e(){"number"==typeof window.innerWidth?n=window.innerWidth:document.documentElement&&document.documentElement.clientWidth&&(n=document.documentElement.clientWidth);var e=n>1024?200:100,t={render:"image",size:e,fill:"#2ca6cb",text:r,radius:.5,quiet:1},a=$(".article-share-qrcode").position();$(".hoverqrcode").empty().css("width",e).css("height",e).css("left",a.left-e/2+20).css("top",a.top-e-10).qrcode(t)}var t=$(".share"),r=t.attr("data-url"),a=encodeURIComponent(r),i=t.attr("data-title"),c=t.attr("data-tsina"),o=(t.attr("description"),['<div class="hoverqrcode clearfix"></div>','<a class="overlay" id="qrcode"></a>','<a href="https://www.facebook.com/sharer.php?u='+a+'" class="article-share-facebook" target="_blank" title="Facebook"></a>','<a href="https://twitter.com/intent/tweet?url='+a+'" class="article-share-twitter" target="_blank" title="Twitter"></a>','<a href="#qrcode" class="article-share-qrcode" title="微信"></a>','<a href="http://widget.renren.com/dialog/share?resourceUrl='+a+"&srcUrl="+a+"&title="+i+'" class="article-share-renren" target="_blank" title="人人"></a>','<a href="http://service.weibo.com/share/share.php?title='+i+"&url="+a+"&ralateUid="+c+'&searchPic=true&style=number" class="article-share-weibo" target="_blank" title="微博"></a>','<span title="Share to"></span>'].join(""));t.append(o),$(".hoverqrcode").hide();var n=0;$(window).resize(function(){$(".hoverqrcode").hide()}),$(".article-share-qrcode").click(function(){e(),$(".hoverqrcode").toggle()}),$(".article-share-qrcode").hover(function(){},function(){$(".hoverqrcode").hide()})})</script><script type="text/javascript">var duoshuoQuery={short_name:"yjaelexblog"};!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//static.duoshuo.com/embed.js",e.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script type="text/javascript">$(document).ready(function(){$(".article-content").each(function(a){$(this).find("img").each(function(){if(!$(this).parent().hasClass("fancybox")){var a=this.alt;a&&$(this).after('<span class="caption">'+a+"</span>"),$(this).wrap('<a href="'+this.src+'" title="'+a+'" class="fancybox"></a>')}}),$(this).find(".fancybox").each(function(){$(this).attr("rel","article"+a)})}),$.fancybox&&$(".fancybox").fancybox()})</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?202299ed0711ed4f90ea1e0b0fd936f1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div id="totop"><a title="返回顶部"><img alt="返回顶部" src="/img/scrollup.png"></a></div><script src="/js/totop.js"></script></body><!-- rebuild by neat -->