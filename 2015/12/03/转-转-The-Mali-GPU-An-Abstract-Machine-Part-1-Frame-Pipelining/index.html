<!-- build time:Thu Dec 29 2016 17:14:09 GMT+0800 (China Standard Time) --><!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="UTF-8"><title>[转][转]The Mali GPU: An Abstract Machine, Part 1 - Frame Pipelining-蓝天和白云的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="author" content="Alex"><meta name="keywords" content="计算机图形, yjaelex, 蓝天和白云"><meta name="google-site-verification" content="9lcaJdZKsghYWk19tQSzSIdlKxsT0jta8L0Qnc2WLSM"><meta name="description" content="转三篇ARM一个牛人写的怎样优化OpenGL ES应用程序的文章。该系列三篇文章，深入浅出介绍了OpenGL ES API的背后实现和ARM GPU硬件架构。其中第一篇是所有图形API都通用的概念；后面介绍了Tile-based rendering和ARM自己Shader Core。这是第一篇，有中英文对照的。"><meta property="og:type" content="article"><meta property="og:title" content="[转][转]The Mali GPU: An Abstract Machine, Part 1 - Frame Pipelining"><meta property="og:url" content="http://yjaelex.github.io/2015/12/03/转-转-The-Mali-GPU-An-Abstract-Machine-Part-1-Frame-Pipelining/index.html"><meta property="og:site_name" content="蓝天和白云的博客"><meta property="og:description" content="转三篇ARM一个牛人写的怎样优化OpenGL ES应用程序的文章。该系列三篇文章，深入浅出介绍了OpenGL ES API的背后实现和ARM GPU硬件架构。其中第一篇是所有图形API都通用的概念；后面介绍了Tile-based rendering和ARM自己Shader Core。这是第一篇，有中英文对照的。"><meta property="og:image" content="http://static.blog.csdn.net/xheditor/xheditor_emot/default/smile.gif"><meta property="og:image" content="https://community.arm.com/servlet/JiveServlet/downloadImage/38-2755-6948/gles-sync.png"><meta property="og:image" content="https://community.arm.com/servlet/JiveServlet/downloadImage/38-2755-6949/gles-async.png"><meta property="og:image" content="https://community.arm.com/servlet/JiveServlet/downloadImage/38-2755-6950/gles-mali.png"><meta property="og:image" content="https://community.arm.com/servlet/JiveServlet/downloadImage/38-2755-6951/gles-mali-throttle.png"><meta property="og:image" content="https://community.arm.com/servlet/JiveServlet/downloadImage/38-2755-6952/gles-mali-vsync.png"><meta property="og:image" content="https://community.arm.com/servlet/JiveServlet/downloadImage/38-3304-8413/gles-sync.png"><meta property="og:image" content="https://community.arm.com/servlet/JiveServlet/downloadImage/38-3304-8420/gles-async.png"><meta property="og:image" content="https://community.arm.com/servlet/JiveServlet/downloadImage/38-3304-8421/gles-mali.png"><meta property="og:image" content="https://community.arm.com/servlet/JiveServlet/downloadImage/38-3304-8422/gles-mali-throttle.png"><meta property="og:image" content="https://community.arm.com/servlet/JiveServlet/downloadImage/38-3304-8423/gles-mali-vsync.png"><meta property="og:updated_time" content="2016-12-29T08:42:10.263Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="[转][转]The Mali GPU: An Abstract Machine, Part 1 - Frame Pipelining"><meta name="twitter:description" content="转三篇ARM一个牛人写的怎样优化OpenGL ES应用程序的文章。该系列三篇文章，深入浅出介绍了OpenGL ES API的背后实现和ARM GPU硬件架构。其中第一篇是所有图形API都通用的概念；后面介绍了Tile-based rendering和ARM自己Shader Core。这是第一篇，有中英文对照的。"><meta name="twitter:image" content="http://static.blog.csdn.net/xheditor/xheditor_emot/default/smile.gif"><link rel="alternative" href="/atom.xml" title="蓝天和白云的博客" type="application/atom+xml"><link rel="icon" href="/img/favicon.ico"><link rel="apple-touch-icon" href="/img/jacman.jpg"><link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg"><link rel="stylesheet" href="/css/style.css"></head></html><body><header><div><div id="imglogo"><a href="/"><img src="/img/logo.png" alt="蓝天和白云的博客" title="蓝天和白云的博客"></a></div><div id="textlogo"><h1 class="site-name"><a href="/" title="蓝天和白云的博客">蓝天和白云的博客</a></h1><h2 class="blog-motto">一个计算机图形爱好者</h2></div><div class="navbar"><a class="navbutton navmobile" href="#" title="菜单"></a></div><nav class="animated"><ul><ul><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/about">关于</a></li><li><form class="search" action="http://zhannei.baidu.com/cse/search" target="_blank"><label>Search</label><input name="s" type="hidden" value="6862289814022638000"><input type="text" name="q" size="30" placeholder="搜索"><br></form></li></ul></ul></nav></div></header><div id="container"><div id="main" class="post" itemscope itemprop="blogPost"><article itemprop="articleBody"><header class="article-info clearfix"><h1 itemprop="name"><a href="/2015/12/03/转-转-The-Mali-GPU-An-Abstract-Machine-Part-1-Frame-Pipelining/" title="[转][转]The Mali GPU: An Abstract Machine, Part 1 - Frame Pipelining" itemprop="url">[转][转]The Mali GPU: An Abstract Machine, Part 1 - Frame Pipelining</a></h1><p class="article-author">By <a href="/about" title="Alex" target="_blank" itemprop="author">Alex</a></p><p class="article-time"><time datetime="2015-12-03T01:55:35.000Z" itemprop="datePublished">发表于 2015-12-03</time></p></header><div class="article-content"><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-英文原文"><span class="toc-number">1.</span> <span class="toc-text">1. 英文原文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-中文翻译"><span class="toc-number">2.</span> <span class="toc-text">2. 中文翻译</span></a></li></ol></div><p>转三篇ARM一个牛人写的怎样优化OpenGL ES应用程序的文章。该系列三篇文章，深入浅出介绍了OpenGL ES API的背后实现和</p><p>ARM GPU硬件架构。其中第一篇是所有图形API都通用的概念；后面介绍了Tile-based rendering和ARM自己Shader Core。</p><p>这是第一篇，有中英文对照的。<img src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/smile.gif" alt="微笑"></p><a id="more"></a><h2 id="1-英文原文"><a href="#1-英文原文" class="headerlink" title="1. 英文原文"></a>1. 英文原文</h2><p>Optimization of graphics workloads is often essential to many modern mobile applications, as almost all rendering is now handled directly or indirectly by an OpenGL ES based rendering back-end. One of my colleagues,&nbsp;<a href="https://community.arm.com/people/mcgeagh" rel="external nofollow noopener noreferrer" target="_blank">Michael<br>McGeagh</a><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline">&nbsp;, recently posted a work guide [</span><a href="https://community.arm.com/docs/DOC-8055" rel="external nofollow noopener noreferrer" target="_blank">http://community.arm.com/docs/DOC-8055</a><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline">]<br>on getting the ARM® DS-5™ Streamline™ profiling tools working with the Google Nexus 10 for the purposes of profiling and optimizing graphical applications using the Mali™-T604 GPU. Streamline is a powerful tool giving high resolution visibility of the entire<br>system’s behavior, but it requires the engineer driving it to interpret the data, identify the problem area, and subsequently propose a fix.</span></p><p>&nbsp;</p><p>For developers who are new to graphics optimization it is fair to say that there is a little bit of a learning curve when first starting out, so this new series of blogs is all about giving content developers the essential knowledge they need to successfully<br>optimize for Mali GPUs. Over the course of the series, I will explore the fundamental macro-scale architectural structures and behaviors developers have to worry about, how this translates into possible problems which can be triggered by content, and finally<br>how to spot them in Streamline.</p><p>&nbsp;</p><p>##<br>Abstract Rendering Machine</p><p>&nbsp;</p><p>The most essential piece of knowledge which is needed to successfully analyze the graphics performance of an application is a mental model of how the system beneath the OpenGL ES API functions, enabling an engineer to reason about the behavior they observe.</p><p>&nbsp;</p><p>To avoid swamping developers in implementation details of the driver software and hardware subsystem, which they have no control over and which is therefore of limited value, it is useful to define a simplified abstract machine which can be used as the basis<br>for explanations of the behaviors observed. There are three useful parts to this machine, and they are mostly orthogonal so I will cover each in turn over the first few blogs in this series, but just so you know what to look forward to the three parts of the<br>model are:</p><p>&nbsp;</p><ul><li>The CPU-GPU rendering pipeline</li><li>Tile-based rendering</li><li>Shader core architecture</li></ul><p>&nbsp;</p><p>In this blog we will look at the first of these, the CPU-GPU rendering pipeline.</p><p>&nbsp;</p><p>##<br>Synchronous API, Asynchronous Execution</p><p>&nbsp;</p><p>The most fundamental piece of knowledge which is important to understand is the temporal relationship between the application’s function calls at the OpenGL ES API and the execution of the rendering operations those API calls require. The OpenGL ES API is specified<br>as a synchronous API from the application perspective. The application makes a series of function calls to set up the state needed by its next drawing task, and then calls a&nbsp;<span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-family:'courier new',courier;vertical-align:baseline">glDraw</span><sup><small style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:.92em;font-family:inherit;vertical-align:baseline">[1]</small></sup>&nbsp;function<br>— commonly called a draw call — to trigger the actual drawing operation. As the API is synchronous all subsequent API behavior after the draw call has been made is specified to behave as if that rendering operation has already happened, but on nearly all hardware-accelerated<br>OpenGL ES implementations this is an elaborate illusion maintained by the driver stack.</p><p>&nbsp;</p><p>In a similar fashion to the draw calls, the second illusion that is maintained by the driver is the end-of-frame buffer flip. Most developers first writing an OpenGL ES application will tell you that calling&nbsp;<span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-family:'courier new',courier;vertical-align:baseline">eglSwapBuffers</span>&nbsp;swaps<br>the front and back-buffer for their application. While this is logically true, the driver again maintains the illusion of synchronicity; on nearly all platforms the physical buffer swap may happen a long time later.</p><p>&nbsp;</p><p>###<br>Pipelining</p><p>&nbsp;</p><p>The reason for needing to create this illusion at all is, as you might expect, performance. If we forced the rendering operations to actually happen synchronously you would end up with the GPU idle when the CPU was busy creating the state for the next draw<br>operation, and the CPU idle while the GPU was rendering. For a performance critical accelerator all of this idle time is obviously not an acceptable state of affairs.</p><p><a href="https://community.arm.com/servlet/JiveServlet/showImage/38-2755-6948/gles-sync.png" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://community.arm.com/servlet/JiveServlet/downloadImage/38-2755-6948/gles-sync.png" alt="gles-sync.png"></a></p><p>&nbsp;</p><p>To remove this idle time we use the OpenGL ES driver to maintain the illusion of synchronous rendering behavior, while actually processing rendering and frame swaps asynchronously under the hood. By running asynchronously we can build a small backlog of work,<br>allowing a pipeline to be created where the GPU is processing older workloads from one end of the pipeline, while the CPU is busy pushing new work into the other. The advantage of this approach is that, provided we keep the pipeline full, there is always work<br>available to run on the GPU giving the best performance.</p><p>&nbsp;</p><p><a href="https://community.arm.com/servlet/JiveServlet/showImage/38-2755-6949/gles-async.png" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://community.arm.com/servlet/JiveServlet/downloadImage/38-2755-6949/gles-async.png" alt="gles-async.png"></a></p><p>&nbsp;</p><p>The units of work in the Mali GPU pipeline are scheduled on a per render-target basis, where a render target may be a window surface or an off-screen render buffer. A single render target is processed in a two step process. First, the GPU processes the vertex<br>shading<sup><small style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:.92em;font-family:inherit;vertical-align:baseline">[2]</small></sup>&nbsp;for all draw calls in the render target, and second, the fragment shading<sup><small style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:.92em;font-family:inherit;vertical-align:baseline">[3]</small></sup>&nbsp;for<br>the entire render target is processed. The logical rendering pipeline for Mali is therefore a three-stage pipeline of: CPU processing, geometry processing, and fragment processing stages.</p><p>&nbsp;</p><p><a href="https://community.arm.com/servlet/JiveServlet/showImage/38-2755-6950/gles-mali.png" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://community.arm.com/servlet/JiveServlet/downloadImage/38-2755-6950/gles-mali.png" alt="gles-mali.png"></a></p><p>&nbsp;</p><p>###<br>Pipeline Throttling</p><p>&nbsp;</p><p>An observant reader may have noticed that the fragment work in the figure above is the slowest of the three operations, lagging further and further behind the CPU and geometry processing stages. This situation is not uncommon; most content will have far more<br>fragments to shade than vertices, so fragment shading is usually the dominant processing operation.</p><p>&nbsp;</p><p>In reality it is desirable to minimize the amount of latency from the CPU work completing to the frame being rendered – nothing is more frustrating to an end user than interacting with a touch screen device where their touch event input and the data on-screen<br>are out of sync by a few 100 milliseconds – so we don’t want the backlog of work waiting for the fragment processing stage to grow too large. In short we need some mechanism to slow down the CPU thread periodically, stopping it queuing up work when the pipeline<br>is already full-enough to keep the performance up.</p><p>&nbsp;</p><p>This throttling mechanism is normally provided by the host windowing system, rather than by the graphics driver itself. On Android for example we cannot process any draw operations in a frame until we know the buffer orientation, because the user may have rotated<br>their device, changing the frame size. SurfaceFlinger — the Android window surface manager – can control the pipeline depth simply by refusing to return a buffer to an application’s graphics stack if it already has more than N buffers queued for rendering.</p><p>&nbsp;</p><p>If this situation occurs you would expect to see the CPU going idle once per frame as soon as “N” is reached, blocking inside an EGL or OpenGL ES API function until the display consumes a pending buffer, freeing up one for new rendering operations.</p><p>&nbsp;</p><p><a href="https://community.arm.com/servlet/JiveServlet/showImage/38-2755-6951/gles-mali-throttle.png" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://community.arm.com/servlet/JiveServlet/downloadImage/38-2755-6951/gles-mali-throttle.png" alt="gles-mali-throttle.png"></a></p><p>&nbsp;</p><p>This same scheme also limits the pipeline buffering if the graphics stack is running faster than the display refresh rate; in this scenario content is &quot;vsync limited&quot; waiting for the vertical blank (vsync) signal which tells the display controller it can switch<br>to the next front-buffer. If the GPU is producing frames faster than the display can show them then SurfaceFlinger will accumulate a number of buffers which have completed rendering but which still need showing on the screen; even though these buffers are<br>no longer part of the Mali pipeline, they count towards the N frame limit for the application process.</p><p>&nbsp;</p><p><a href="https://community.arm.com/servlet/JiveServlet/showImage/38-2755-6952/gles-mali-vsync.png" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://community.arm.com/servlet/JiveServlet/downloadImage/38-2755-6952/gles-mali-vsync.png" alt="gles-mali-vsync.png"></a></p><p>As you can see in the pipeline diagram above, if content is vsync limited it is common to have periods where both the CPU and GPU are totally idle. Platform dynamic voltage and frequency scaling (DVFS) will typically try to reduce the current operating frequency<br>in these scenarios, allowing reduced voltage and energy consumption, but as DVFS frequency choices are often relatively coarse some amount of idle time is to be expected.</p><p>&nbsp;</p><p>###<br>Summary</p><p>&nbsp;</p><p>In this blog we have looked at synchronous illusion provided by the OpenGL ES API, and the reasons for actually running an asynchronous rendering pipeline beneath the API. Tune in&nbsp;<a href="https://community.arm.com/groups/arm-mali-graphics/blog/2014/02/20/the-mali-gpu-an-abstract-machine-part-2" rel="external nofollow noopener noreferrer" target="_blank">next<br>time</a>, and I’ll continue to develop the abstract machine further, looking at the Mali GPU’s tile-based rendering approach.</p><p>&nbsp;</p><p>Comments and questions welcomed,</p><p>Pete</p><p>&nbsp;</p><p>###<br>Footnotes</p><p>&nbsp;</p><ul><li>[1] There are many OpenGL ES draw functions which draw things, it doesn’t really matter which one you pick for this example.</li><li>[2]&nbsp;<a href="https://community.arm.com/external-link.jspa?url=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FVertex_%28computer_graphics%29" rel="external nofollow noopener noreferrer" target="_blank">Vertex<br>(computer graphics) - Wikipedia, the free encyclopedia</a></li><li>[3]&nbsp;<a href="https://community.arm.com/external-link.jspa?url=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FFragment_%28computer_graphics%29" rel="external nofollow noopener noreferrer" target="_blank">Fragment<br>(computer graphics) - Wikipedia, the free encyclopedia</a></li></ul><h2 id="2-中文翻译"><a href="#2-中文翻译" class="headerlink" title="2. 中文翻译"></a>2. 中文翻译</h2><p><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">图形工作负载的优化对于许多现代移动应用程序而言往往必不可少，因为几乎所有渲染现在都直接或间接地由基于</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;OpenGL</span></p><p>ES&nbsp;<span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">的渲染后端负责处理。我的同事</span>&nbsp;<span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-family:Arial,sans-serif;vertical-align:baseline"><a href="https://community.arm.com/people/mcgeagh" rel="external nofollow noopener noreferrer" target="_blank"><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:inherit;vertical-align:baseline;color:#0481a5">Michael<br>McGeagh</span></a></span>&nbsp;<span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">最近发表了一篇工作指南</span>&nbsp;<span style="margin:0;padding:0;border:1pt windowtext;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline">[</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-family:Arial,sans-serif;vertical-align:baseline"><a href="https://community.arm.com/docs/DOC-8055" rel="external nofollow noopener noreferrer" target="_blank"><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:inherit;vertical-align:baseline;color:#0481a5">http://community.arm.com/docs/DOC-8055</span></a></span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">]</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">，介绍如何将</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;ARM®DS-5™<br>Streamline™&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">性能分析工具用于</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;Google<br>Nexus 10</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">，对利用</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">Mali™-T604<br>GPU&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">的图形应用程序进行性能分析和优化。</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">Streamline&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">是一款强大的工具，能够深入细致地洞悉整个系统的行为，但也需要驾驭它的工程师能够解读相关数据，识别问题区域，进而提出修复建议。</span></p><p><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">对于初涉图形优化的开发人员而言，起步阶段总会遇到一些困难，所以我写了新的系列博文，给开发人员提供必要的知识，以便他们能够成功地针对</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;Mali<br>GPU<span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline">进行优化。在整个系列博文中，我将阐述开发人员必须要考虑的基本宏观体系结构和行为、这些因素如何转化为能被内容触发的潜在问题，以及最终如何在</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;vertical-align:baseline"></span></span></p><p>Streamline&nbsp;<span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline">中找出这些问题。</span></p><p>&nbsp;</p><p>##<br><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:15pt;font-family:SimSun;vertical-align:baseline;color:#4e5584">抽象渲染机器</span></p><p><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">要想成功分析应用程序的图形性能，必须先掌握一个最基本的知识，也就是对</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;OpenGL<br>ES API&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">底下系统运作方式建立一个心智模型，让工程师能够推断他们观察到的行为。</span></p><p><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">为避免让开发人员陷于驱动程序软件和硬件子系统的实施细节的沼泽之中（这些他们无法控制，因而价&#20540;有限），有必要定义一个简化的抽象机器，用作解读所观察到的行为的基础。这一机器包含三个有用部分，它们大体上是独立不相干的，所以我将在本系列博文的开头几篇中逐一介绍。不过，为了让你对它们有个初步印象，下面列出该模型的三个部分：</span></p><ul><li><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Symbol;vertical-align:baseline;color:#000"><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline">CPU-GPU&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline">渲染管线</span></span></li><li><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Symbol;vertical-align:baseline;color:#000"><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline">基于区块的渲染</span></span></li><li><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Symbol;vertical-align:baseline;color:#000"><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline"></span></span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Symbol;vertical-align:baseline;color:#000"><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline">着色器核心架构</span></span></li></ul><p><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">在本篇博文中，我们将探讨第一个部分，即</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;CPU-GPU&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">渲染管线。</span></p><p>&nbsp;</p><p>##<br><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:15pt;font-family:SimSun;vertical-align:baseline;color:#4e5584">同步</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:15pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#4e5584">API</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:15pt;font-family:SimSun;vertical-align:baseline;color:#4e5584">，异步执行</span></p><p><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">务必要了解的一个基本知识是，</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">OpenGL<br>ES API&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">上应用程序函数调用和这些</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;API&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">调用所需渲染运算的执行之间的临时关系。从应用程序的角度而言，</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">OpenGL<br>ES API&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">被指定为同步</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;API</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">。应用程序进行一系列的函数调用来设置其下一绘制任务所需的状态，然后调用</span>&nbsp;<span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">glDraw</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:9pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">[1]</span>&nbsp;<span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">函数（通常称为绘制调用）触发实际的绘制运算。由于</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;API&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">是同步的，执行绘制调用后的所有</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;API&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">行为都被指定为要像渲染运算已经发生一样进行，但在几乎所有硬件加速的</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;OpenGL<br>ES&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">实现上，这只是一种由驱动程序堆栈维持的美妙假象。</span></p><p><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">与绘制调用相&#20284;，驱动程序维持的第二个假象是帧末缓冲翻转。大多数头一次编写</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;OpenGL<br>ES&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">应用程序的开发人员会告诉你，调用</span>&nbsp;<span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">eglSwapBuffers<span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline">将交换其应用程序的前缓冲和后缓冲。虽然这在逻辑上是对的，但驱动程序再一次维持了同步性的假象；在几乎所有平台上，实际的缓冲交换可能会在很久之后才会发生。</span></span></p><p><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:12pt;font-family:SimSun;vertical-align:baseline;color:#4e5584"></span>&nbsp;</p><p>###<br><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:12pt;font-family:SimSun;vertical-align:baseline;color:#4e5584">管线化</span></p><p><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">正如你所想到的，需要创造这一假象的原因在于性能。如果我们强制渲染运算真正同步发生，你就会面临这样的尴尬：</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">CPU&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">忙于创建下一绘制运算的状态时，</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">GPU&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">会闲置；</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">GPU&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">执行渲染时，</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">CPU&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">会闲置。对于以性能为重的加速器而言，所有这些闲置时间都是绝然不可接受的。</span></p><div style="margin:0;padding:0;border:0;font-size:14px;font-family:'Gill Sans Alt One WGL W01 Lt';vertical-align:baseline;color:#565b5b;line-height:25px;text-align:justify"><br><span style="margin:0;padding:0;border:1pt windowtext;font-weight:inherit;font-style:inherit;font-family:Arial,sans-serif;vertical-align:baseline"><a href="https://community.arm.com/servlet/JiveServlet/showImage/38-3304-8413/gles-sync.png" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://community.arm.com/servlet/JiveServlet/downloadImage/38-3304-8413/gles-sync.png" alt="gles-sync.png"></a><a href="https://community.arm.com/servlet/JiveServlet/downloadImage/38-2755-6948/gles-sync.png" rel="external nofollow noopener noreferrer" target="_blank"><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:inherit;vertical-align:baseline;color:#0481a5"><br><br></span></a></span></div><br><div style="margin:0;padding:0;border:0;font-size:14px;font-family:'Gill Sans Alt One WGL W01 Lt';vertical-align:baseline;color:#565b5b;line-height:25px;text-align:justify"><br><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">为了去除这一闲置时间，我们使用</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;OpenGL<br>ES&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">驱动程序来维持同步渲染行为的假象，而在面纱之后实际是以异步执行的方式处理渲染和帧交换。通过异步运行，我们可以建立一个小小的工作储备以允许创建一个管线，</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">GPU&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">从管线的一端处理较旧的工作负载，而</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;CPU&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">则负责将新的工作推入另一端。这一方式的优势在于，只要管线装满，就始终有工作在</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;GPU&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">上运行，提供最佳的性能。</span></div><p><a href="https://community.arm.com/servlet/JiveServlet/showImage/38-3304-8420/gles-async.png" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://community.arm.com/servlet/JiveServlet/downloadImage/38-3304-8420/gles-async.png" alt="gles-async.png"></a></p><p>&nbsp;</p><div style="margin:0;padding:0;border:0;font-size:14px;font-family:'Gill Sans Alt One WGL W01 Lt';vertical-align:baseline;color:#565b5b;line-height:25px;text-align:justify"><br><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">Mali GPU&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">管线中的工作单元是以渲染目标为单位进行计划的，其中渲染目标可能是屏幕缓存或离屏缓存。单个渲染目标通过两步处理。首先，</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">GPU&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">为渲染目标中的所有绘制调用处理顶点着色</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">[2]</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-family:SimSun;vertical-align:baseline">。</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">然后，为整个渲染目标处理片段着色</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">[3]</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-family:SimSun;vertical-align:baseline">。</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">因此，</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">Mali&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">的逻辑渲染管线包含三个阶段：</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">CPU&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">处理阶段、几何处理阶段，以及片段处理阶段。</span></div><p>&nbsp;</p><p><a href="https://community.arm.com/servlet/JiveServlet/showImage/38-3304-8421/gles-mali.png" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://community.arm.com/servlet/JiveServlet/downloadImage/38-3304-8421/gles-mali.png" alt="gles-mali.png"></a></p><p>&nbsp;</p><p><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:12pt;font-family:SimSun;vertical-align:baseline;color:#4e5584">管线节流</span></p><p><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">观察力敏锐的读者可能已注意到，上图中片段部分的工作是三个运算中最慢的，被</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;CPU&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">和几何处理阶段甩得越来越远。这种情形并不少见；大多数内容中要着色的片段远多于顶点，因此片段着色通常是占主导地位的处理运算。</span></p><p><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">在现实中，最好要尽可能缩短从</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;CPU&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">工作结束到帧被渲染之间的延时</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;–&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">对最终用户而言，最让人烦躁的莫过于在操作触控屏设备时，其触控事件输入和屏幕中数据显示之间出现数百毫秒的不同步</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;–&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">所以，我们不希望等待片段处理阶段的工作储备变得过大。简而言之，我们需要某种机制来定期减慢</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;CPU&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">线程，当管线足够满、能够维持良好性能时停止把工作放入队列。</span></p><p><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">这种节流机制通常由主机窗口系统提供，而不是图形驱动程序本身。例如，在</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;Android&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">上，我们只有在知道缓冲方向时才能处理任何绘制运算，因为用户可能会旋转其设备，造成帧大小出现变化。</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">SurfaceFlinger—<br>Android&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">窗口表面管理器</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;–&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">可以通过一个简单方式控制管线深度：当管线中排队等待渲染的缓冲数量超过</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;N&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">个时，拒绝将缓冲返回到应用程序的图形堆栈。</span></p><p><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">如果出现这种情形，你就会看到：一旦每一帧达到</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">“N”</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">时</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;CPU&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">就会进入闲置状态，在内部阻止</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;EGL&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">或</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;OpenGL</span></p><p>ES API&nbsp;<span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">函数，直到显示屏消耗完一个待处理缓存，为新的渲染运算空出一个位置。</span></p><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp;<a href="https://community.arm.com/servlet/JiveServlet/showImage/38-3304-8422/gles-mali-throttle.png" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://community.arm.com/servlet/JiveServlet/downloadImage/38-3304-8422/gles-mali-throttle.png" alt="gles-mali-throttle.png"></a></p><p><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">如果图形堆栈的运行快于显示刷新率，同样的方案也可限制管线缓冲；在这一情形下，内容受到</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">VSYNC</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">限制</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">”</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">并等待垂直空白（</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">VSYNC</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">同步）信号，该信号告诉显示控制器它可以切换到下一缓冲。如果</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;GPU&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">产生帧的速度快于显示屏显示帧的速度，那么</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000"></span></p><p>SurfaceFlinger&nbsp;<span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">将积累一定数量已经完成渲染但依然需要显示在屏幕上的缓冲；即使这些缓冲不再是</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;Mali&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">管线的一个部分，它们依然算在应用程序进程的</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;N&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">帧限制内。</span></p><p><a href="https://community.arm.com/servlet/JiveServlet/showImage/38-3304-8423/gles-mali-vsync.png" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://community.arm.com/servlet/JiveServlet/downloadImage/38-3304-8423/gles-mali-vsync.png" alt="gles-mali-vsync.png"></a></p><p><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">正如上面的管线示意图所示，如果内容受到</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">VSYNC</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">同步限制，那么会经常出现</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;CPU&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">和</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;GPU&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">都完全闲置的时段。平台动态电压和频率调节</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;(DVFS)&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">通常会在此类情形中尝试降低当前的工作频率，以降低电压和功耗，但由于</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;DVFS&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">频率选择通常相对粗糙，所以可能会出现一定数量的闲置时间。</span></p><p>&nbsp;</p><p><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline">小结</span></p><p><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">本篇博文中，我们探讨了</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;OpenGL<br>ES API&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">提供的同步假象，以及</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;API&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">下实际运行异步渲染管线的原因。敬请<span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:13.33px;vertical-align:baseline">期待</span></span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-family:Arial,sans-serif;vertical-align:baseline;color:#000"><a href="https://community.arm.com/groups/arm-mali-graphics/blog/2014/02/20/the-mali-gpu-an-abstract-machine-part-2" rel="external nofollow noopener noreferrer" target="_blank"><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">下一篇</span></a></span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">博文，我将继续往下开发这一台抽象机器，探讨</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">&nbsp;Mali<br>GPU<span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline">基于区块的渲染做法。</span></span></p><p><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#000">欢迎大家提出意见和问题。</span></p><p><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">Pete</span></p><p>&nbsp;</p><p>&nbsp;</p><div style="margin:0;padding:0;border:0;font-size:14px;font-family:'Gill Sans Alt One WGL W01 Lt';vertical-align:baseline;color:#565b5b;line-height:25px;text-align:justify"><br><br><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:12pt;font-family:SimSun;vertical-align:baseline;color:#4e5584">脚注</span></div><p><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Symbol;vertical-align:baseline;color:#000"><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline">[1]&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline">执行绘制的</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline">&nbsp;OpenGL<br>ES&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline">绘制函数有许多，本例中选用哪一个其实没什么关系。</span></span></p><p><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Symbol;vertical-align:baseline"><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Arial,sans-serif;vertical-align:baseline;color:#000">[2]&nbsp;</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:13.33px;font-family:Arial,sans-serif;vertical-align:baseline"><a href="https://community.arm.com/external-link.jspa?url=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FVertex_%28computer_graphics%29" rel="external nofollow noopener noreferrer" target="_blank"><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:inherit;vertical-align:baseline;color:#0481a5">Vertex<br>(computer graphics) –&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#0481a5">（顶点（计算机图形））</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:inherit;vertical-align:baseline;color:#0481a5">&nbsp;-&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#0481a5">维基百科，自由的百科全书</span>&nbsp;&nbsp;</a></span></span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Symbol;vertical-align:baseline"><span class="pasted-list-info" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:13.33px;font-family:inherit;vertical-align:baseline"></span></span></p><p><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:Symbol;vertical-align:baseline"><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:13.33px;font-family:Arial,sans-serif;vertical-align:baseline">[3]</span>&nbsp;<span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:13.33px;font-family:Arial,sans-serif;vertical-align:baseline"><a href="https://community.arm.com/external-link.jspa?url=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FFragment_%28computer_graphics%29" rel="external nofollow noopener noreferrer" target="_blank"><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:inherit;vertical-align:baseline;color:#0481a5">Fragment<br>(computer graphics) -&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#0481a5">（片段（计算机图形））</span><span style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:inherit;vertical-align:baseline;color:#0481a5">&nbsp;-&nbsp;</span><span lang="ZH-CN" style="margin:0;padding:0;border:0;font-weight:inherit;font-style:inherit;font-size:10pt;font-family:SimSun;vertical-align:baseline;color:#0481a5">维基百科，自由的百科全书</span>&nbsp;&nbsp;</a></span></span></p><p><br>本文地址 <a href="http://yjaelex.github.io/2015/12/03/转-转-The-Mali-GPU-An-Abstract-Machine-Part-1-Frame-Pipelining/">http://yjaelex.github.io/2015/12/03/转-转-The-Mali-GPU-An-Abstract-Machine-Part-1-Frame-Pipelining/</a> 作者为<a href="/about/"> Alex</a></p></div><div style="font-size:16px;BORDER-BOTTOM:#bbb 1px solid;BORDER-LEFT:#bbb 1px solid;BACKGROUND:#f6f6f6;MIN-HEIGHT:120px;BORDER-TOP:#bbb 1px solid;BORDER-RIGHT:#bbb 1px solid;MARGIN-LEFT:10px;MARGIN-RIGHT:10px;MARGIN-BOTTOM:10px" class="oec2003right"><div style="MARGIN-TOP:10px;FLOAT:left;MARGIN-LEFT:10px;MARGIN-RIGHT:10px"><img alt="author:Alex" src="http://yjaelex.github.io/imgs/myself.jpg" width="100" height="100"></div><div style="LINE-HEIGHT:200%;MARGIN:10px;COLOR:#000">Author: <a href="https://www.linkedin.com/in/yjaelex" rel="external nofollow noopener noreferrer" target="_blank">Alex</a> &nbsp&nbsp&nbsp&nbsp Blog: <a href="http://yjaelex.github.io/">http://yjaelex.github.io/</a>&nbsp&nbsp&nbsp&nbsp Email: <a href="mailto:yjaelex@163.com" rel="external nofollow noopener noreferrer" target="_blank">yjaelex@163.com</a><br>I have almost 9 years of professional 3D graphics development experiences(D3D/OpenGL) and have solid experience of graphics driver developement, for both DirectX and OpenGL/ES.</div></div><footer class="article-footer clearfix"><div class="article-catetags"></div><div class="article-share" id="share"><div data-url="http://yjaelex.github.io/2015/12/03/转-转-The-Mali-GPU-An-Abstract-Machine-Part-1-Frame-Pipelining/" data-title="[转][转]The Mali GPU: An Abstract Machine, Part 1 - Frame Pipelining | 蓝天和白云的博客" data-tsina="undefined" class="share clearfix"></div></div></footer></article><nav class="article-nav clearfix"><div class="prev"><a href="/2015/12/03/转-转-The-Mali-GPU-An-Abstract-Machine-Part-2-Tile-based-Rendering/" title="[转][转] The Mali GPU: An Abstract Machine, Part 2 - Tile-based Rendering"><strong>上一篇：</strong><br><span>[转][转] The Mali GPU: An Abstract Machine, Part 2 - Tile-based Rendering</span></a></div><div class="next"><a href="/2015/11/08/转-转-8-reasons-why-SPIR-V-makes-a-big-difference/" title="[转][转] 8 reasons why SPIR-V makes a big difference"><strong>下一篇：</strong><br><span>[转][转] 8 reasons why SPIR-V makes a big difference</span></a></div></nav><section id="comments" class="comment"><div class="ds-thread" data-thread-key="2015/12/03/转-转-The-Mali-GPU-An-Abstract-Machine-Part-1-Frame-Pipelining/" data-title="[转][转]The Mali GPU: An Abstract Machine, Part 1 - Frame Pipelining" data-url="http://yjaelex.github.io/2015/12/03/转-转-The-Mali-GPU-An-Abstract-Machine-Part-1-Frame-Pipelining/"></div></section></div><div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div><div id="toc" class="toc-aside"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-英文原文"><span class="toc-number">1.</span> <span class="toc-text">1. 英文原文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-中文翻译"><span class="toc-number">2.</span> <span class="toc-text">2. 中文翻译</span></a></li></ol></div><div id="asidepart"><div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div><aside class="clearfix"><div class="github-card"><p class="asidetitle">Github 名片</p><div class="github-card" data-github="yjaelex" data-width="220" data-height="119" data-theme="medium"><script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js"></script></div></div><div class="tagcloudlist"><p class="asidetitle">标签云</p><div class="tagcloudlist clearfix"><a href="/tags/Graphics/" style="font-size:10px">Graphics</a> <a href="/tags/Mantle/" style="font-size:10px">Mantle</a></div></div><div class="archiveslist"><p class="asidetitle"><a href="/archives">归档</a></p><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">4</span></li></ul></div><div class="tagslist"><p class="asidetitle">标签</p><ul class="clearfix"><li><a href="/tags/Mantle/" title="Mantle">Mantle<sup>1</sup></a></li><li><a href="/tags/Graphics/" title="Graphics">Graphics<sup>1</sup></a></li></ul></div><div class="hotarticles"><p class="asidetitle">热评文章</p><div class="ds-top-threads" data-range="monthly" data-num-items="5"></div></div><div class="linkslist"><p class="asidetitle">友情链接</p><ul><li><a href="http://blog.csdn.net/qwertyu1234" target="_blank" title="蓝天和白云的CSDN博客">蓝天和白云的CSDN博客</a></li><li><a href="https://github.com/yjaelex/" target="_blank" title="Alex&#39;s Github" rel="external nofollow noopener noreferrer">Alex&#39;s Github</a></li></ul></div><div class="rsspart"><a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a></div></aside></div></div><footer><div id="footer"><div class="line"><span></span><div class="author"></div></div><section class="info"><p>图形学爱好者的家园<br></p></section><div class="social-font"><a href="https://github.com/yjaelex" target="_blank" class="icon-github" title="github" rel="external nofollow noopener noreferrer"></a> <a href="https://www.linkedin.com/in/yjaelex" target="_blank" class="icon-linkedin" title="linkedin" rel="external nofollow noopener noreferrer"></a> <a href="mailto:yjaelex@163.com" target="_blank" class="icon-email" title="Email Me" rel="external nofollow noopener noreferrer"></a></div><p class="copyright">Copyright ©2014-2016 <a href="/about" target="_blank" title="Alex">Alex</a></p></div><script type="text/javascript">var cnzz_protocol="https:"==document.location.protocol?" https://":" http://";document.write(unescape("%3Cspan style='display:none;' id='cnzz_stat_icon_1260545070'%3E%3C/span%3E%3Cscript src='"+cnzz_protocol+"s95.cnzz.com/z_stat.php%3Fid%3D1260545070' type='text/javascript'%3E%3C/script%3E"))</script><script type="text/javascript">!function(t,e,n,s,c,i,a){t.SwiftypeObject=c,t[c]=t[c]||function(){(t[c].q=t[c].q||[]).push(arguments)},i=e.createElement(n),a=e.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","//s.swiftypecdn.com/install/v2/st.js","_st"),_st("install","qFtymqNnfXjgmwxAJxMP","2.0.0")</script></footer><script src="/js/jquery-2.0.3.min.js"></script><script src="/js/jquery.imagesloaded.min.js"></script><script src="/js/gallery.js"></script><script src="/js/jquery.qrcode-0.12.0.min.js"></script><script type="text/javascript">$(document).ready(function(){function e(){"number"==typeof window.innerWidth?n=window.innerWidth:document.documentElement&&document.documentElement.clientWidth&&(n=document.documentElement.clientWidth)}$(".navbar").click(function(){$("header nav").toggleClass("shownav")});var n=0,s=$("#main"),a=$("#asidepart"),o=$(".closeaside"),d=$(".openaside");o.click(function(){a.addClass("fadeOut").css("display","none"),d.css("display","block").addClass("fadeIn"),s.addClass("moveMain")}),d.click(function(){d.css("display","none").removeClass("beforeFadeIn"),a.css("display","block").removeClass("fadeOut").addClass("fadeIn"),s.removeClass("moveMain")}),$(window).scroll(function(){d.css("top",Math.max(80,260-$(this).scrollTop()))}),$(window).resize(function(){e(),n>=1024?$("header nav").removeClass("shownav"):(s.removeClass("moveMain"),a.css("display","block").removeClass("fadeOut"),d.css("display","none"),$("#toc.toc-aside").css("display","none"))})})</script><script type="text/javascript">$(document).ready(function(){var c=$(".article-content>iframe"),n=$(".article-content>embed"),o=($("#toc"),$("#toc.toc-aside")),e=$(".openaside"),i=$(".closeaside");c.length>0&&c.wrap('<div class="video-container" />'),n.length>0&&n.wrap('<div class="video-container" />'),i.click(function(){o.css("display","block").addClass("fadeIn")}),e.click(function(){o.css("display","none")}),$(window).scroll(function(){o.css("top",Math.max(140,320-$(this).scrollTop()))})})</script><script type="text/javascript">$(document).ready(function(){function e(){"number"==typeof window.innerWidth?n=window.innerWidth:document.documentElement&&document.documentElement.clientWidth&&(n=document.documentElement.clientWidth);var e=n>1024?200:100,t={render:"image",size:e,fill:"#2ca6cb",text:r,radius:.5,quiet:1},a=$(".article-share-qrcode").position();$(".hoverqrcode").empty().css("width",e).css("height",e).css("left",a.left-e/2+20).css("top",a.top-e-10).qrcode(t)}var t=$(".share"),r=t.attr("data-url"),a=encodeURIComponent(r),i=t.attr("data-title"),c=t.attr("data-tsina"),o=(t.attr("description"),['<div class="hoverqrcode clearfix"></div>','<a class="overlay" id="qrcode"></a>','<a href="https://www.facebook.com/sharer.php?u='+a+'" class="article-share-facebook" target="_blank" title="Facebook"></a>','<a href="https://twitter.com/intent/tweet?url='+a+'" class="article-share-twitter" target="_blank" title="Twitter"></a>','<a href="#qrcode" class="article-share-qrcode" title="微信"></a>','<a href="http://widget.renren.com/dialog/share?resourceUrl='+a+"&srcUrl="+a+"&title="+i+'" class="article-share-renren" target="_blank" title="人人"></a>','<a href="http://service.weibo.com/share/share.php?title='+i+"&url="+a+"&ralateUid="+c+'&searchPic=true&style=number" class="article-share-weibo" target="_blank" title="微博"></a>','<span title="Share to"></span>'].join(""));t.append(o),$(".hoverqrcode").hide();var n=0;$(window).resize(function(){$(".hoverqrcode").hide()}),$(".article-share-qrcode").click(function(){e(),$(".hoverqrcode").toggle()}),$(".article-share-qrcode").hover(function(){},function(){$(".hoverqrcode").hide()})})</script><script type="text/javascript">var duoshuoQuery={short_name:"yjaelexblog"};!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//static.duoshuo.com/embed.js",e.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script type="text/javascript">$(document).ready(function(){$(".article-content").each(function(a){$(this).find("img").each(function(){if(!$(this).parent().hasClass("fancybox")){var a=this.alt;a&&$(this).after('<span class="caption">'+a+"</span>"),$(this).wrap('<a href="'+this.src+'" title="'+a+'" class="fancybox"></a>')}}),$(this).find(".fancybox").each(function(){$(this).attr("rel","article"+a)})}),$.fancybox&&$(".fancybox").fancybox()})</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?202299ed0711ed4f90ea1e0b0fd936f1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div id="totop"><a title="返回顶部"><img alt="返回顶部" src="/img/scrollup.png"></a></div><script src="/js/totop.js"></script></body><!-- rebuild by neat -->